#!/usr/bin/env bash
#
# shrink-backup
# version 1.0.1-beta
# backup tool for backing up and updating .img files with autoexpansion on various operating systems
#
#    Copyright (c) 2024, Marcus Johansson
#    https://github.com/UnconnectedBedna/shrink-backup
#    All rights reserved.
#
#    This source code is licensed under the BSD-style license found in the
#    LICENSE file in the root directory of this source tree.
##############################################################################

# Function to clean up resources on script exit or termination
function cleanup() {
  # exit 0 = cleanup after script
  # exit 1 = later/normal error
  # exit 2 = help & looprun
  # exit 3 = early/clean error
  # exit 4 = abort early
  # exit 5 = abort later
  # exit 10 = stopped by user mid script (ctrl+c)
  local exit_code="$?"

  if [ "$exit_code" -ne 2 ] && [ "$exit_code" -ne 3 ]; then
    case $exit_code in
      0) debug 'DEBUG' 'Cleanup function called with exit 0';;
      4) debug 'WARNING' 'Script aborted by user early, cleanup exit 4';;
      5) debug 'WARNING' 'Script aborted by user later, cleanup exit 5';;
      10) echo -e '\n## Script stopped by user...'; debug 'WARNING' 'Script stopped by user with ctrl+c, cleanup exit 10';;
      *) echo '## Cleanup function called with non zero exit code, something went wrong!!!'; debug 'ERROR' "Cleanup function called with non zero exit code: exit $exit_code";;
    esac

    echo '## Exiting and cleaning up...'
    echo '## Please stand by...'

    if [ -n "$BOOT_PATH" ] && [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR}${BOOT_PATH} " /proc/mounts; then
      # Loop until the mount point is not busy
      while true; do
        # Check if the mount point is still busy
        if ! umount "${TMP_DIR}${BOOT_PATH}" && [ -n "$BOOT_PATH" ] && [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR}${BOOT_PATH} " /proc/mounts; then
          # If it is, sleep for a few seconds and try again
          echo "## ${TMP_DIR}${BOOT_PATH} is busy, retrying in 5 seconds"
          debug 'DEBUG' "${TMP_DIR}${BOOT_PATH} is busy, retrying in 5 seconds"
          sleep 5
        else
          # If it's not busy, provide debug info
          debug 'DEBUG' "Unmounting boot partition in cleanup function: umount ${TMP_DIR}${BOOT_PATH}"
          break
        fi
      done
    fi

    if [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR}/home " /proc/mounts; then
      while true; do
        if ! umount "${TMP_DIR}/home" && [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR}/home " /proc/mounts; then
          echo "## ${TMP_DIR}/home is busy, retrying in 5 seconds"
          debug 'DEBUG' "${TMP_DIR}/home is busy, retrying in 5 seconds"
          sleep 5
        else
          debug 'DEBUG' "Unmounting home partition in cleanup function: umount ${TMP_DIR}/home"
          break
        fi
      done
    fi

    if [ -n "$TMP_DIR" ] && grep -qs "$TMP_DIR " /proc/mounts; then
      while true; do
        if ! umount "${TMP_DIR}" && [ -n "$TMP_DIR" ] && grep -qs "$TMP_DIR " /proc/mounts; then
          echo "## ${TMP_DIR} is busy, retrying in 5 seconds"
          debug 'DEBUG' "${TMP_DIR} is busy, retrying in 5 seconds"
          sleep 5
        else
          debug 'DEBUG' "Unmounting root partition in cleanup function: umount ${TMP_DIR}"
          break
        fi
      done
    fi

    if losetup "$LOOP" &>/dev/null; then
      while true; do
        if ! losetup -d "$LOOP"; then
          echo "## ${LOOP} is busy, retrying in 5 seconds"
          debug 'DEBUG' "${LOOP} is busy, retrying in 5 seconds"
          sleep 5
        else
          debug 'DEBUG' "Removing loop in cleanup function: losetup -d $LOOP"
          break
        fi
      done
      #debug 'DEBUG' "Removing loop in cleanup function: losetup -d $LOOP"
      #losetup -d "$LOOP"
    fi

    if [ -d "$TMP_DIR" ]; then
      debug 'DEBUG' "Removing temp directory in cleanup function: rm -rf $TMP_DIR"
      rm -rf "$TMP_DIR"
    fi

    if [ -f "$tmp_file" ]; then
      debug 'DEBUG' "Removing temp file in cleanup function: rm $tmp_file"
      rm "$tmp_file"
    fi

    echo '## Done.'
    echo "## Elapsed time: $(date -d@$SECONDS -u +%M.%S)"
    debug 'INFO' "Elapsed time: $(date -d@$SECONDS -u +%M.%S)"
    debug 'DEBUG' 'Exiting script'
    if [ "$DEBUG" = true ]; then
      echo '##############################################################################' >> "$LOG_FILE"
    fi
  fi
}
trap cleanup EXIT SIGTERM
trap "exit 10" SIGINT

# Function to pause script execution and prompt for user input
function pause() {
  read -p "$*"
}

# Uncomment the following line to enable the pause function
#pause 'Press [Enter] key to continue...'

# Set default values for script options
PROMPTS=true
DEBUG=false
EXCLUDE_FILE=false
AUTOEXPAND=true
AUTORESIZE_RUN=false
UPDATE=false
LOG_FILE="$(dirname $0)/shrink-backup.log"
AUTORESIZE_WARNING=false
ZOOM=false
LOOPRUN=false
RSYNC_DELETE='--delete'
F2FS=false
#STARTLINE="$0 $*" # will produce doubble // if script is in $PATH
STARTLINE="$(dirname $0)/$(basename $0) $*" # will produce absolute path if script is in $PATH
#STARTLINE="$(realpath $0) $*" # same as bove, but will ALWYAS prodice absolute path

# If no TTY is available (for example running custom command in webmin)
if [ -t 0 ]; then
  TTY_AVAILABILITY='/dev/tty'

  # Colors
  Red='\033[0;31m'
  Blue='\033[0;34m'
  Green='\033[0;32m'
  #Yellow='\033[0;33m'
  Yellow='\033[0;93m' # high intensity yellow
  NC='\033[0m' # Text Reset - No colors
else
  TTY_AVAILABILITY='/dev/null'
fi

# Function to display help information
help() {
  local help
  read -r -d '' help << EOM
Script for creating an .img file and subsequently keeing it updated (-U), autoexpansion is enabled by default
Directory where .img file is created is automatically excluded in backup
########################################################################
Usage: ${Green}sudo $(basename "$0") [-Uatyelzh] [--fix] [--loop] [--f2fs] imagefile.img [extra space (MiB)]${NC}
  -U            Update existing img file (rsync to existing img)
                  Optional [extra space] extends img root partition
  -a            Autocalculate root size partition, [extra space] is ignored
                  When used in combination with -U:
                  Expand if partition is >=256MiB smaller than autocalculated recommended minimum
                  Shrink if partition is >=512MiB bigger than autocalculated recommended minimum
  -t            Use exclude.txt in same folder as script to set excluded directories
                  One directory per line: "/dir" or "/dir/*" to only exclude contents
  -y            Disable prompts in script (please use this option with care!)
  -e            DISABLE autoexpansion on root filesystem when image is booted
  -l            Write debug messages to logfile shrink-backup.log located in same directory as script
  -z            Make script zoom at light-speed, only question prompts might slow it down
                  Can be combined with -y for UNSAFE ultra-mega-superduper-speed
  --fix         Try to fix the img file if -a fails with a "broken pipe" error
  --loop [img]  Loop img file and exit, works in combination with -l & -z
                  If optional [extra space] is defined, the img file will be extended with the amount before looping
                  NOTE that only the file gets truncated, no partitions
                  Useful if you for example want to manually manage the partitions
  --f2fs        Convert root filesystem on img from ext4 to f2fs
                  Only works on new img file, not in combination with -U
                  Will make backups of fstab & cmdline.txt to: fstab.shrink-backup.bak & cmdline.txt.shrink-backup.bak
                  Then change ext4 to f2fs in both files and add discard to options on root partition in fstab
  -h --help     Show this help snippet
########################################################################
${Blue}Examples:
${Green}sudo $(basename "$0") -a /path/to/backup.img ${NC}(create img, automatically set size)
${Green}sudo $(basename "$0") -e -y /path/to/backup.img 1024 ${NC}(create img, ignore prompts, do NOT autoexpand, add 1024MiB extra space)
${Green}sudo $(basename "$0") -Utl /path/to/backup.img ${NC}(update img backup, use exclude.txt and write log to shrink-backup.log)
${Green}sudo $(basename "$0") -U /path/to/backup.img 1024 ${NC}(update img backup, expand img size/root partition with 1024MiB)
${Green}sudo $(basename "$0") -Ua /path/to/backup.img ${NC}(update img backup, automatically resizes img file if needed)
${Green}sudo $(basename "$0") -Ua --fix /path/to/backup.img 1024 ${NC}(update img backup, automatically resizes img file if needed, fix img free space)
${Green}sudo $(basename "$0") -l --loop /path/to/backup.img 1024 ${NC}(write to log file, expand IMG FILE (not partition) by 1024MiB, loop then exit script)
EOM
  echo -e "$help"
  exit 2
}

# Parse command-line options
options=$(getopt -o Uatyelzh --long help,fix,f2fs,loop: -- "$@")
[ $? -eq 0 ] || {
    echo -e "${Red}Incorrect options provided${NC}"
    help
}
eval set -- "$options"
while true; do
  case "$1" in
    -U) UPDATE=true; shift;;
    -a) AUTORESIZE_RUN=true; shift;;
    -t) EXCLUDE_FILE=true; shift;;
    -y) PROMPTS=false; shift;;
    -e) AUTOEXPAND=false; shift;;
    -l) DEBUG=true; shift;;
    -z) ZOOM=true; shift;;
    -h|--help) help; break;;
    --fix) RSYNC_DELETE='--delete-before'; shift;;
    --f2fs) F2FS=true; shift;;
    --loop) LOOPRUN=true; IMG_FILE="$2"; shift 2;;
    --) break;;
    *) shift;;
  esac
done

# Process the non-option arguments, checks/fixes if the imagefile comes before the options
while [ "$#" -gt 0 ];
do
  if [[ "$1" =~ ^- ]]; then
    shift
  elif [ -n "$IMG_FILE" ]; then
    ADDED_SPACE="$1"
    break
  else
    IMG_FILE="$1"
    ADDED_SPACE="$2"
    break
  fi
done

# Check if script is run as root
if [ "$EUID" != 0 ]; then
  echo -e "${Red}THIS SCRIPT MUST BE RUN AS ROOT! (WITH SUDO)${NC}"
  help
fi



function debug() {
  local log_level="$1"
  local log_message="$2"
  if [ "$DEBUG" = true ]; then
    if [ "$log_level" = 'BREAK' ]; then
      echo '------------------------------------------------------------------------------' >> "$LOG_FILE"
    else
      if [ $log_level = 'INFO' ]; then
        echo -e "$(date +"%Y-%m-%d %H:%M:%S") [$log_level]  - $log_message" >> "$LOG_FILE"
      else
        echo -e "$(date +"%Y-%m-%d %H:%M:%S") [$log_level] - $log_message" >> "$LOG_FILE"
      fi
    fi
  fi
  return 0
}



# Function to loop the img file and exit
function looprun() {
  if [ "$ADDED_SPACE" -ne 0 ]; then
    echo -e "## ${Red}WARNING!${NC} You have requested to add ${ADDED_SPACE}MiB to the img file"
    read -p "Do you want to continue with the truncate operation? [y/n] " -n 1 -r
    debug 'INFO' 'Do you want to continue with the truncate operation? [y/n]'
    if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
      echo ''
      echo -e "${Red}## Aborting...${NC}"
      exit 4
    fi
    echo ''
    debug 'INFO' 'Y or y pressed to confirm'
    echo "## Truncating file by adding ${ADDED_SPACE}MiB"
    $SLEEPING
    #truncate -s +$(( ADDED_SPACE * 1024 * 1024 )) "$IMG_FILE"
    if ! output=$(truncate -s +$(( ADDED_SPACE * 1024 * 1024 )) "$IMG_FILE" 2>&1); then
      echo -e "$output\n!! TRUNCATE FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "TRUNCATE FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  fi

  debug 'INFO' 'Running function: do_loop'
  $SLEEPING
  do_loop

  echo "## $IMG_FILE is looped to $LOOP"
  echo '##############################################################################'
  echo -e "${Green}$(lsblk $LOOP)${NC}"
  echo '##############################################################################'
  echo '## Done.'

  debug 'DEBUG' 'Exiting script, exit 2'
  if [ "$DEBUG" = true ]; then
    echo '##############################################################################' >> "$LOG_FILE"
  fi
exit 2
}



# Function to gather device information
function get_dev_variables() {

  # Run get_btrfs_variables and then exit THIS function
  if [ "$FSTYPE" = 'btrfs' ] && [ "$AUTORESIZE_RUN" = false ] && [ "$ADDED_SPACE" -eq 0 ]; then
    debug 'INFO' 'Running function: get_btrfs_variables'
    get_btrfs_variables
    return 0
  fi

  ADDED_SPACE=$(( ADDED_SPACE * 1024 * 1024 )) # bytes, ADDED_SPACE=0 if AUTORESIZE_RUN=true

  # Check if separate boot and root partition exists and set variables accordingly
  if grep -q 'boot' /etc/fstab; then
    debug 'INFO' 'Separate boot partition detected'
    LOCAL_DEV_BOOT_PATH=$(lsblk -lpo mountpoint,path | grep 'boot' | awk '{print $2}')
    LOCAL_DEV_ROOT_PATH=$(mount | grep '/ ' | awk '{print $1}')
    debug 'DEBUG' "LOCAL_DEV_BOOT_PATH=$LOCAL_DEV_BOOT_PATH | LOCAL_DEV_ROOT_PATH=$LOCAL_DEV_ROOT_PATH"
    LOCAL_BOOT_UUID=$(lsblk -o uuid "$LOCAL_DEV_BOOT_PATH" | tail -1)
    LOCAL_ROOT_UUID=$(lsblk -o uuid "$LOCAL_DEV_ROOT_PATH" | tail -1)
    LOCAL_ROOT_PARTUUID=$(lsblk -o partuuid "$LOCAL_DEV_ROOT_PATH" | tail -1)
    debug 'DEBUG' "LOCAL_BOOT_UUID=$LOCAL_BOOT_UUID | LOCAL_ROOT_UUID=$LOCAL_ROOT_UUID | LOCAL_ROOT_PARTUUID=$LOCAL_ROOT_PARTUUID"
    BOOT_PATH=$(cat /etc/fstab | grep '/boot' | awk '{print $2}')
    debug 'DEBUG' "BOOT_PATH=$BOOT_PATH"
  else
    debug 'INFO' 'No boot partition detected'
    #LOCAL_DEV_ROOT_PATH=$(lsblk -lpo mountpoint,path | grep '/ ' | awk '{print $2}')
    LOCAL_DEV_ROOT_PATH=$(mount | grep '/ ' | awk '{print $1}')
    debug 'DEBUG' "LOCAL_DEV_ROOT_PATH=$LOCAL_DEV_ROOT_PATH"
    LOCAL_ROOT_UUID=$(lsblk -o uuid "$LOCAL_DEV_ROOT_PATH" | tail -1)
    LOCAL_ROOT_PARTUUID=$(lsblk -o partuuid "$LOCAL_DEV_ROOT_PATH" | tail -1)
    debug 'DEBUG' "LOCAL_ROOT_UUID=$LOCAL_ROOT_UUID | LOCAL_ROOT_PARTUUID=$LOCAL_ROOT_PARTUUID"
  fi
  LOCAL_ROOT_PARTN=$(parted -sm "$LOCAL_DEV_PATH" print | tail -1 | cut -d : -f 1)
  debug 'DEBUG' "LOCAL_ROOT_PARTN=$LOCAL_ROOT_PARTN"

  # Collect information about partition sizes
  #if [ "$UPDATE" = false ] || [ "$ADDED_SPACE" -ne 0 ] || [ "$AUTORESIZE_RUN" = true ]; then
#     debug 'INFO' 'Calculating size for dd to cover bootsector in blocks (512B block size) and adding 256 blocks to overlap into root (only used in img creation)'
#     debug 'DEBUG' "Running: fdisk -lo start "$LOCAL_DEV_PATH" | tail -1"
#     LOCAL_ROOT_START=$(fdisk -lo start "$LOCAL_DEV_PATH" | tail -1 | awk '{print $1}') # blocks, 512B block size
#     LOCAL_BOOTSECTOR=$(( LOCAL_ROOT_START - 1 )) # blocks, to set the actual bootsector
#     LOCAL_DDBOOTSECTOR=$(( LOCAL_BOOTSECTOR + 256 )) # blocks, adding 256 extra to cover root filesystem
#     debug 'DEBUG' "LOCAL_ROOT_START=$LOCAL_ROOT_START blocks | LOCAL_BOOTSECTOR=$LOCAL_BOOTSECTOR blocks | LOCAL_DDBOOTSECTOR=$LOCAL_DDBOOTSECTOR blocks"
#     LOCAL_ROOT_START=$(( LOCAL_ROOT_START * 512 )) # bytes
#     LOCAL_BOOTSECTOR=$(( LOCAL_BOOTSECTOR * 512 )) # bytes
#     debug 'DEBUG' "LOCAL_ROOT_START=$LOCAL_ROOT_START bytes | LOCAL_BOOTSECTOR=$LOCAL_BOOTSECTOR bytes"
    debug 'INFO' 'Calculating size for dd to cover bootsector and adding 5MiB (5242880 bytes) to overlap into root (only used in img creation)'
    LOCAL_ROOT_START=$(fdisk -lo device,start "$LOCAL_DEV_PATH" | grep "$LOCAL_DEV_ROOT_PATH" | awk '{print $2}') # 512B blocks
    LOCAL_BOOTSECTOR=$(( LOCAL_ROOT_START - 1 )) # blocks, to set the actual bootsector, needed in case no boot partition exists
    LOCAL_ROOT_START=$(( LOCAL_ROOT_START * 512 )) # bytes
    LOCAL_BOOTSECTOR=$(( LOCAL_BOOTSECTOR * 512 )) # bytes
    #LOCAL_BOOTSECTOR=$(lsblk --bytes -o size "$LOCAL_DEV_BOOT_PATH" | tail -1) # bytes, can not be used, will be 0 if no boot partition exists
    LOCAL_DDBOOTSECTOR=$(( (LOCAL_BOOTSECTOR + 5242880) / 512 )) # 512B blocks, 5242880 = 5MiB in bytes
    debug 'DEBUG' "LOCAL_ROOT_START=$LOCAL_ROOT_START bytes | LOCAL_BOOTSECTOR=$LOCAL_BOOTSECTOR bytes | LOCAL_DDBOOTSECTOR=$LOCAL_DDBOOTSECTOR 4k blocks"
  #fi

  # Set automated calculated size (get_btrfs_variables if btrfs filesystem)
  if [ "$AUTORESIZE_RUN" = true ] || [ "$UPDATE" = false ] || [ "$FSTYPE" == 'btrfs' ]; then
    debug 'INFO' 'Calculating recommended root size'
    BLOCKSIZE=$(stat -f / | grep -i 'Block size' | awk '{print $3}') # bytes
    debug 'DEBUG' "BLOCKSIZE=${BLOCKSIZE} bytes"
    if [ "$FSTYPE" == 'ext4' ]; then
      debug 'INFO' 'ext4 filesystem detected, using resize2fs to set recommended root size'
      LOCAL_AUTORESIZE_MIN=$(resize2fs -P "$LOCAL_DEV_ROOT_PATH" 2>/dev/null | awk '{print $7}') # blocks
      LOCAL_AUTORESIZE_MIN=$(( LOCAL_AUTORESIZE_MIN * BLOCKSIZE )) # bytes
      debug 'DEBUG' "LOCAL_AUTORESIZE_MIN=${LOCAL_AUTORESIZE_MIN} bytes"
    elif [ "$FSTYPE" == 'f2fs' ]; then
      #debug 'INFO' 'f2fs filesystem detected, using du (+512MiB) instead to calculate recommended root size'
      #LOCAL_AUTORESIZE_MIN=$(du -xsb / | awk '{print $1}') # bytes
      #LOCAL_AUTORESIZE_MIN=$(( LOCAL_AUTORESIZE_MIN + 536870912 )) # adding 512MiB
      debug 'INFO' 'f2fs filesystem detected, using df (+512MiB) to set recommended root size'
      # Method 2, using "used space" straight up
      LOCAL_AUTORESIZE_DF=$(df / -k --sync --output=used | tail -1) # 1k blocks
      LOCAL_AUTORESIZE_MIN=$(( LOCAL_AUTORESIZE_DF * 1024 )) # bytes
      LOCAL_AUTORESIZE_MIN=$(( LOCAL_AUTORESIZE_MIN + 536870912 )) # adding 512MiB
      debug 'DEBUG' "LOCAL_AUTORESIZE_MIN=${LOCAL_AUTORESIZE_MIN} bytes"
    else
      debug 'INFO' 'Running function: get_btrfs_variables'
      get_btrfs_variables
    fi
  fi

  # Method 1, using the value of "size - available"
  #declare -a LOCAL_DF_OUTPUT=( $(df / -k --sync --output=size,avail | tail -1) ) # 1k blocks, 0 is the first position in an array
  #LOCAL_USED_SPACE=$(( (${LOCAL_DF_OUTPUT[0]} - ${LOCAL_DF_OUTPUT[1]}) * 1024 )) # bytes, df is in 1k blocks, 0 is the first position

  # Method 2, using "used space" straight up
  declare -a LOCAL_DF_OUTPUT=( $(df / -k --sync --output=used | tail -1) ) # 1k blocks
  LOCAL_USED_SPACE=$(( LOCAL_DF_OUTPUT * 1024 )) # bytes, df is in 1k blocks

  # Set recommended size if option is selected
  if [ "$AUTORESIZE_RUN" = true ]; then
    debug 'INFO' 'Setting TOTAL (space needed for files on root) to autocalculated size'
    TOTAL=$LOCAL_AUTORESIZE_MIN # bytes
  else
    debug 'INFO' 'Calculating TOTAL (space needed for files on root) by adding LOCAL_USED_SPACE and ADDED_SPACE'
    debug 'DEBUG' "LOCAL_USED_SPACE=${LOCAL_USED_SPACE} bytes | ADDED_SPACE=${ADDED_SPACE} bytes"
    TOTAL=$(( LOCAL_USED_SPACE + ADDED_SPACE )) # bytes
  fi
  debug 'DEBUG' "TOTAL=${TOTAL} bytes"
  TRUNCATE_TOTAL=$(( LOCAL_BOOTSECTOR + TOTAL )) # bytes
  debug 'INFO' 'Calculating .img file size by adding LOCAL_BOOTSECTOR to TOTAL'
  debug 'DEBUG' "TRUNCATE_TOTAL=${TRUNCATE_TOTAL} bytes"

  # Add 128MiB extra space if autocalculated size reports bigger minimum than created on new img
  if [ "$UPDATE" = false ] && [ "$TOTAL" -lt "$LOCAL_AUTORESIZE_MIN" ]; then
    debug 'WARNING' 'Adding WIGGLEROOM (128MiB) because manually requested ADDED_SPACE is less than autocaluclated size'
    AUTORESIZE_WARNING=true
    WIGGLEROOM=134217728 # 128MiB = 134217728B, 192MiB = 201326592B
    TRUNCATE_TOTAL=$(( TRUNCATE_TOTAL + WIGGLEROOM ))
    debug 'DEBUG' "AUTORESIZE_WARNING=$AUTORESIZE_WARNING | WIGGLEROOM=${WIGGLEROOM} bytes | TRUNCATE_TOTAL=${TRUNCATE_TOTAL} bytes"
  fi
return 0
}



# Function to gather btrfs information
function get_btrfs_variables() {

  BOOT_PATH=$(cat /etc/fstab | grep '/boot' | awk '{print $2}')
  debug 'DEBUG' "BOOT_PATH=$BOOT_PATH"

  if [ "$AUTORESIZE_RUN" = true ]; then
    debug 'INFO' 'Using btrfs fi du to calculate recommended size and adding 192MiB'
    LOCAL_AUTORESIZE_MIN=$(btrfs filesystem du -s --raw / 2>/dev/null) # bytes
    LOCAL_AUTORESIZE_MIN=$(echo "$LOCAL_AUTORESIZE_MIN" | tail -1 | awk '{print $1}')
    LOCAL_AUTORESIZE_MIN=$(( LOCAL_AUTORESIZE_MIN + 201326592 )) # 192MiB = 201326592B
    debug 'DEBUG' "LOCAL_AUTORESIZE_MIN=$LOCAL_AUTORESIZE_MIN bytes"
  fi
  debug 'DEBUG' "Running: btrfs subvolume list / | awk '{print \$9}'"
  #LOCAL_SUBVOLUMES=( $(sudo btrfs subvolume list / | awk '{print $2,$9}') )
  declare -a LOCAL_SUBVOLUMES=( $(btrfs subvolume list / | awk '{print $9}') )
  #local_subvolumes_count=$(( ${#LOCAL_SUBVOLUMES[@]} / 2 ))
  debug 'DEBUG' "LOCAL_SUBVOLUMES=$(echo ${LOCAL_SUBVOLUMES[@]})"
  if [ "$EXCLUDE_FILE" = true ]; then
    debug 'INFO' 'Filtering out volumes from exclude.txt'
    for ((i = 0; i < ${#LOCAL_SUBVOLUMES[@]}; i++)); do
      if $(echo "/${LOCAL_SUBVOLUMES[i]}" | grep -q -f "$(dirname $0)/exclude.txt"); then
        debug 'DEBUG' "Filtering out subvolume: ${LOCAL_SUBVOLUMES[i]}"
        unset LOCAL_SUBVOLUMES["$i"]
      fi
    done
    debug 'DEBUG' "After filtering, LOCAL_SUBVOLUMES=$(echo ${LOCAL_SUBVOLUMES[@]})"
  fi
return 0
}



# Function to gather image information
function get_img_variables() {

  debug 'DEBUG' "Running: ls -l $IMG_FILE | awk '{print \$5}'"
  IMG_SIZE=$(ls -l "$IMG_FILE" | awk '{print $5}')
  debug 'DEBUG' "IMG_SIZE=$IMG_SIZE bytes"

  if grep -q 'boot' /etc/fstab; then
    debug 'INFO' 'Separate boot partition detected'

    # ext4 & f2fs
    if [ "$FSTYPE" == 'ext4' ] || [ "$FSTYPE" == 'f2fs' ]; then
      # I have no idea why, but if I do not put this sleep here, IMG_DEV_BOOT_PATH does not get set
      sleep 2
      #pause 'Press [Enter] key to continue...'
      IMG_DEV_BOOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_BOOT_UUID" | awk '{print $1}')
      IMG_DEV_ROOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
      debug 'DEBUG' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
      # Sleep was not enough, might have to do with slow network if img file is on a network share
      if ! [ -e "$IMG_DEV_BOOT_PATH" ] || ! [ -e "$IMG_DEV_ROOT_PATH" ]; then
        for (( i=1; i<=3; i++ )); do
          echo -e "!! ${Yellow}LOOP paths can not be set, retrying in 5 seconds...${NC}"
          debug 'WARNING' 'LOOP paths can not be set, retrying in 5 seconds'
          debug 'WARNING' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
          sleep 5
          IMG_DEV_BOOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_BOOT_UUID" | awk '{print $1}')
          IMG_DEV_ROOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
          if [ -e "$IMG_DEV_BOOT_PATH" ] && [ -e "$IMG_DEV_ROOT_PATH" ]; then
            echo -e "## ${Green}LOOP paths found, resuming backup...${NC}"
            debug 'INFO' "LOOP paths found, resuming backup"
            debug 'DEBUG' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
            break
          fi
        done
      fi

    # btrfs (old method)
    else
      IMG_DEV_BOOT_PATH="${LOOP}p1"
      IMG_DEV_ROOT_PATH="${LOOP}p2"
      debug 'DEBUG' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
    fi

  else
    debug 'INFO' 'No boot partition detected'
    # I have no idea why, but if I do not put this sleep here, IMG_DEV_ROOT_PATH does not get set
    sleep 2
    #pause 'Press [Enter] key to continue...'
    IMG_DEV_ROOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
    debug 'DEBUG' "IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
  fi

  # check for btrfs subvolumes on img
  if [ "$FSTYPE" = 'btrfs' ]; then
    # Check for temp directory and create if needed
    if ! [ -d "$TMP_DIR" ]; then
      echo '## Creating temp directory...'
      $SLEEPING
      debug 'INFO' 'Creating temp directory'
      debug 'DEBUG' "Running: mktemp -d -t backup-XXX"
      TMP_DIR=$(mktemp -d -t backup-XXX)
      debug 'DEBUG' "TMP_DIR=$TMP_DIR"
    fi
    $SLEEPING
    partprobe "$LOOP"
    declare -a fstab=( $(cat /etc/fstab | grep '/ ') )
    debug 'INFO' 'Mounting root to find subvolumes'
    debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! ROOT MOUNT FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "ROOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    $SLEEPING
    debug 'DEBUG' "Running: btrfs subvolume list $TMP_DIR | awk '{print \$9}'"
    declare -a IMG_SUBVOLUMES=( $(btrfs subvolume list "$TMP_DIR" | awk '{print $9}') )
    debug 'DEBUG' "IMG_SUBVOLUMES=$(echo ${IMG_SUBVOLUMES[@]})"
    debug 'DEBUG' "Running: umount $TMP_DIR"
    umount "$TMP_DIR"
  fi
return 0
}



# Function for shared variables
function set_img_variables() {

  if grep -q 'boot' /etc/fstab; then
    debug 'INFO' 'Separate boot partition detected'

    # ext4 & f2fs
    if [ "$FSTYPE" == 'ext4' ] || [ "$FSTYPE" == 'f2fs' ]; then
      # I have no idea why, but if I do not put this sleep here, IMG_DEV_BOOT_PATH does not get set
      sleep 2
      #pause 'Press [Enter] key to continue...'
      IMG_DEV_BOOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_BOOT_UUID" | awk '{print $1}')
      IMG_DEV_ROOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
      debug 'DEBUG' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
      # Sleep was not enough, might have to do with slow network if img file is on a network share
      if ! [ -e "$IMG_DEV_BOOT_PATH" ] || ! [ -e "$IMG_DEV_ROOT_PATH" ]; then
        for (( i=1; i<=3; i++ )); do
          echo -e "!! ${Yellow}LOOP paths can not be set, retrying in 5 seconds...${NC}"
          debug 'WARNING' 'LOOP paths can not be set, retrying in 5 seconds'
          debug 'WARNING' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
          sleep 5
          IMG_DEV_BOOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_BOOT_UUID" | awk '{print $1}')
          IMG_DEV_ROOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
          if [ -e "$IMG_DEV_BOOT_PATH" ] && [ -e "$IMG_DEV_ROOT_PATH" ]; then
            echo -e "## ${Green}LOOP paths found, resuming backup...${NC}"
            debug 'INFO' "LOOP paths found, resuming backup"
            debug 'DEBUG' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
            break
          fi
        done
      fi

      if ! [ -e "$IMG_DEV_BOOT_PATH" ] || ! [ -e "$IMG_DEV_ROOT_PATH" ]; then
        echo -e "${Red}!! LOOP PATHS CAN NOT BE SET!!!${NC}"
        debug 'ERROR' 'LOOP PATHS CAN NOT BE SET'
        exit 1
      fi

    # btrfs (old method)
    elif [ "$FSTYPE" == 'btrfs' ]; then
      IMG_DEV_BOOT_PATH="${LOOP}p1"
      IMG_DEV_ROOT_PATH="${LOOP}p2"
      debug 'DEBUG' "IMG_DEV_BOOT_PATH=$IMG_DEV_BOOT_PATH | IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
    fi

  else
    debug 'INFO' 'No boot partition detected'
    # I have no idea why, but if I do not put this sleep here, IMG_DEV_ROOT_PATH does not get set
    sleep 2
    #pause 'Press [Enter] key to continue...'
    IMG_DEV_ROOT_PATH=$(lsblk -o path,uuid "$LOOP" | grep "$LOCAL_ROOT_UUID" | awk '{print $1}')
    debug 'DEBUG' "IMG_DEV_ROOT_PATH=$IMG_DEV_ROOT_PATH"
  fi
return 0
}



# Function to loop img file
function do_loop() {

  if [ -z "$LOOP" ]; then
    LOOP=$(losetup -f)
    debug 'DEBUG' "LOOP=$LOOP"
  fi

  echo '## Looping img file...'
  $SLEEPING
  debug 'DEBUG' "Running: losetup -P $LOOP $IMG_FILE"
  if ! output=$(losetup -P "$LOOP" "$IMG_FILE" 2>&1); then
    echo -e "${Yellow}$output\n${Red}!! LOSETUP FAILED!!!${NC}"
    debug 'BREAK'
    debug 'ERROR' "LOSETUP FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
return 0
}



# Function to mount img file
function do_mount() {

  # Check for temp directory and create if needed
  if ! [ -d "$TMP_DIR" ]; then
    echo '## Creating temp directory...'
    $SLEEPING
    debug 'INFO' 'Creating temp directory'
    debug 'DEBUG' "Running: mktemp -d -t backup-XXX"
    TMP_DIR=$(mktemp -d -t backup-XXX)
    debug 'DEBUG' "TMP_DIR=$TMP_DIR"
  fi
  $SLEEPING
  partprobe "$LOOP"

  # ext4 & f2fs
  if [ "$FSTYPE" == 'ext4' ] || [ "$FSTYPE" == 'f2fs' ] || [ "$F2FS" = true ]; then
    echo '## Mounting img root partition...'
    $SLEEPING
    debug 'INFO' 'Mounting root partition from loop'
    debug 'DEBUG' "Running: mount $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! ROOT MOUNT FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "ROOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

  # btrfs
  elif [ "$FSTYPE" == 'btrfs' ]; then
    declare -a fstab=( $(cat /etc/fstab | grep '/ ') )
    echo "## Mounting root subvolume..."
    debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! ROOT SUBVOLUME MOUNT FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "ROOT SUBVOLUME MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    $SLEEPING

    for ((i = 0; i < ${#LOCAL_SUBVOLUMES[@]}; i++)); do
      subvol_path="${LOCAL_SUBVOLUMES[i]}"
      #if $(cat /etc/fstab | grep -q "$subvol_path") && [[ "$subvol_path" != '@' ]]; then
      if grep -q "$subvol_path" /etc/fstab && [[ "$subvol_path" != '@' ]]; then
        declare -a fstab=( $(cat /etc/fstab | grep "$subvol_path") )
        if ! [ -d "${TMP_DIR}${fstab[1]}" ]; then
          debug 'DEBUG' "Running: mkdir -p ${TMP_DIR}${fstab[1]}"
          mkdir -p "${TMP_DIR}${fstab[1]}"
        fi
        echo "## Mounting subvolume: $subvol_path"
        debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH ${TMP_DIR}${fstab[1]}"
        if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" ${TMP_DIR}${fstab[1]} 2>&1); then
          echo -e "${Yellow}$output\n${Red}!! SUBVOLUME MOUNT FAILED!!!${NC}"
          debug 'BREAK'
          debug 'ERROR' "SUBVOLUME MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
          exit 1
        fi

      elif [[ "$subvol_path" != '@'* ]]; then
        if ! [ -d "${TMP_DIR}/${subvol_path}" ]; then
          debug 'DEBUG' "Running: mkdir -p ${TMP_DIR}/${subvol_path}"
          mkdir -p "${TMP_DIR}/${subvol_path}"
        fi
      fi
      $SLEEPING
    done
  fi

  # Checking if boot partition exists and if true, mount boot
  #if [ $(lsblk | grep -c 'boot') -ne 0 ]; then
  if [ -n "$BOOT_PATH" ]; then
    if ! lsblk | grep -q 'boot'; then
      echo "${Red}!! BOOT PARTITION NOT MOUNTED ON SYSTEM, PLEASE MOUNT BOOT PARTITION AND RE-RUN THE SCRIPT!!!${NC}"
      debug 'ERROR' 'BOOT PARTITION NOT MOUNTED ON SYSTEM, PLEASE MOUNT BOOT PARTITION AND RE-RUN THE SCRIPT!!!'
      exit 1
    fi
    echo '## Mounting img boot partition...'
    $SLEEPING
    debug 'INFO' 'Separate boot partition detected, mounting boot inside root'
    if ! [ -d ${TMP_DIR}${BOOT_PATH} ]; then
      debug 'INFO' 'Boot directory did not exist on img'
      debug 'DEBUG' "Running: mkdir -p ${TMP_DIR}${BOOT_PATH}"
      mkdir -p ${TMP_DIR}${BOOT_PATH}
    fi
    debug 'DEBUG' "Running: mount $IMG_DEV_BOOT_PATH ${TMP_DIR}${BOOT_PATH}"
    if ! output=$(mount "$IMG_DEV_BOOT_PATH" "${TMP_DIR}${BOOT_PATH}" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! BOOT MOUNT FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "BOOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  fi
return 0
}



# Function to check filesystem
function do_e2fsck() {

  if [ -n "$BOOT_PATH" ] && [ -n "$TMP_DIR" ] && grep -qs "${TMP_DIR}${BOOT_PATH} " /proc/mounts; then
    debug 'INFO' 'Unmounting boot partition'
    debug 'DEBUG' "Running: umount ${TMP_DIR}${BOOT_PATH}"
    umount "${TMP_DIR}${BOOT_PATH}"
  fi

  if [ -n "$TMP_DIR" ] && grep -qs "$TMP_DIR " /proc/mounts; then
    debug 'INFO' 'Unmounting root partition'
    debug 'DEBUG' "Running: umount $TMP_DIR"
    umount "$TMP_DIR"
  fi

  # Final check of filesystem
  if [ "$*" = 'final' ]; then
    echo '## Finalizing filesystem...'
    $SLEEPING

    output=$(e2fsck -p -f -v "$IMG_DEV_ROOT_PATH" 2>&1)
    echo "$output"
    debug 'BREAK'
    debug 'DEBUG' "Running: e2fsck -p -f -v $IMG_DEV_ROOT_PATH\n$output\n------------------------------------------------------------------------------"
    $SLEEPING

    # Remounting if autoexpansion is requested
    if [ "$AUTOEXPAND" = true ]; then
      echo '## Remounting for autoexpansion...'
      debug 'INFO' 'Remounting for autoexpansion function'
      debug 'INFO' 'Running function: do_mount'
      $SLEEPING
      do_mount
    fi

  else
    # Normal check
    echo '## Checking img filesystem...'
    $SLEEPING

    output=$(e2fsck -p -f "$IMG_DEV_ROOT_PATH" 2>&1)
    echo "$output"
    debug 'DEBUG' "Running: e2fsck -p -f $IMG_DEV_ROOT_PATH\n$output\n------------------------------------------------------------------------------"
    $SLEEPING
  fi

return 0
}



# Function to resize image
function do_resize() {

  # Reading offset for img root partition
  debug 'INFO' 'Using fdisk to find img root partition offset'
  debug 'DEBUG' "Running: fdisk -lo start $IMG_FILE | tail -1"
  IMG_ROOT_START=$(fdisk -lo start "$IMG_FILE" | tail -1 | awk '{print $1}') # blocks, 521B block size
  debug 'DEBUG' "IMG_ROOT_START=$IMG_ROOT_START blocks"
  IMG_ROOT_START=$(( IMG_ROOT_START * 512 )) # bytes
  debug 'DEBUG' "IMG_ROOT_START=${IMG_ROOT_START}B"

  # Converting TOTAL > TOTALK (bytes > kibibytes)
  debug 'INFO' 'Converting TOTAL > TOTALK (bytes > kibibytes)'
  TOTALK=$(( TOTAL / 1024 )) # kibibytes
  debug 'DEBUG' "TOTAL=${TOTAL}B | TOTALK=${TOTALK}KiB"

  # Gather information
  debug 'INFO' 'Using parted to fetch root partition number'
  debug 'DEBUG' "Running: parted -sm "$LOOP" print | tail -1 | cut -d : -f 1"
  IMG_ROOT_PARTN=$(parted -sm "$LOOP" print | tail -1 | cut -d : -f 1)
  debug 'DEBUG' "IMG_ROOT_PARTN=$IMG_ROOT_PARTN"

  # Check img filesystem
  debug 'INFO' 'Running function: do_e2fsck'
  do_e2fsck


  # Expanding
  if [ "$*" = 'expand' ]; then

    echo '## Expanding img filesystem...'
    $SLEEPING

    # Removing loop for tuncate to take effect
    echo '## Removing loop...'
    $SLEEPING
    debug 'INFO' 'Removing loop for truncate to take effect'
    debug 'DEBUG' "Running: losetup -d $LOOP"
    losetup -d "$LOOP"

    echo "## Resizing image file..."
    $SLEEPING
    debug 'INFO' "Using truncate to resize img file to $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
    debug 'DEBUG' "Running: truncate --size=$TRUNCATE_TOTAL $IMG_FILE"
    if ! output=$(truncate --size="$TRUNCATE_TOTAL" "$IMG_FILE" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! TRUNCATE FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "TRUNCATE FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

    # Loop img file
    debug 'INFO' 'Re-looping img file to fetch new img size'
    debug 'INFO' 'Running function: do_loop'
    do_loop

    echo '## Removing partition...'
    $SLEEPING
    #debug 'INFO' 'Using sfdisk to remove root partition'
    debug 'INFO' 'Using parted to remove root partition'
    #debug 'DEBUG' "Running: sfdisk --delete -f $LOOP $IMG_ROOT_PARTN"
    debug 'DEBUG' "Running: parted -s $LOOP rm $IMG_ROOT_PARTN"
    #debug 'DEBUG' "Running: printf 'Ignore\\\n'$IMG_ROOT_PARTN | parted $LOOP rm $IMG_ROOT_PARTN ---pretend-input-tty"

    #if ! output=$(sfdisk --delete -f "$LOOP" "$IMG_ROOT_PARTN" 2>&1); then # might fail if img size is very big
    if ! output=$(parted -s "$LOOP" rm "$IMG_ROOT_PARTN" 2>&1); then # for some reason this line works here but not when creating img
    #if ! output=$(printf 'Ignore\n'$IMG_ROOT_PARTN | parted $LOOP rm $IMG_ROOT_PARTN ---pretend-input-tty 2>&1); then # raspberry pi os does not like this method, keep for memory
      #echo -e "${Yellow}$output\n${Red}!! SFDISK FAILED!!!${NC}"
      echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!${NC}"
      debug 'BREAK'
      #debug 'ERROR' "SFDISK FAILED:\n$output\n------------------------------------------------------------------------------"
      debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

    echo '## Recreating partition...'
    $SLEEPING
    debug 'INFO' 'Using parted to recreate root partition'
    debug 'DEBUG' "Running: parted -s -a none $LOOP unit B mkpart primary ext4 $IMG_ROOT_START 100%"
    if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary ext4 "$IMG_ROOT_START" 100% 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

    echo '## Resizing filesystem...'
    $SLEEPING
    debug 'INFO' 'Using resize2fs to expand filesystem'
    debug 'BREAK'
    debug 'DEBUG' "Running: resize2fs -p -f $IMG_DEV_ROOT_PATH"
    if ! output=$(resize2fs -p -f "$IMG_DEV_ROOT_PATH" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! RESIZE2FS FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "RESIZE2FS FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'DEBUG' "$output\n------------------------------------------------------------------------------"

    # Check img filesystem
    debug 'INFO' 'Running function: do_e2fsck'
    do_e2fsck


  # Shrinking
  elif [ "$*" = 'shrink' ]; then

    echo '## Shrinking filesystem...'
    $SLEEPING
    debug 'INFO' 'Using resize2fs to shrink filesystem'
    debug 'BREAK'
    debug 'DEBUG' "Running: resize2fs -p -f $IMG_DEV_ROOT_PATH ${TOTALK}K"
    if ! output=$(resize2fs -p -f "$IMG_DEV_ROOT_PATH" "$TOTALK"K 2>&1 | tee "$TTY_AVAILABILITY"); then
      echo -e "${Red}$output\n${Red}!! RESIZE2FS FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "RESIZE2FS FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'DEBUG' "$output\n------------------------------------------------------------------------------"

    echo '## Shrinking partition...'
    $SLEEPING
    debug 'INFO' 'Using parted to shrink partition'
    debug 'BREAK'
    #debug 'DEBUG' "Running: parted -s -a none $LOOP unit B resizepart $IMG_ROOT_PARTN $TRUNCATE_TOTAL"
    debug 'DEBUG' "Running: printf 'Yes\\\n' | parted -a none $LOOP unit B resizepart $IMG_ROOT_PARTN $TRUNCATE_TOTAL ---pretend-input-tty"

    #if ! output=$(parted -s -a none "$LOOP" unit B resizepart "$IMG_ROOT_PARTN" "$TRUNCATE_TOTAL" 2>&1); then # tested may 2024 and does not work, still asking for user confirmation even though --script is used
    if ! output=$(printf 'Yes\n' | parted -a none "$LOOP" unit B resizepart "$IMG_ROOT_PARTN" "$TRUNCATE_TOTAL" ---pretend-input-tty 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'DEBUG' "$output\n------------------------------------------------------------------------------"

    echo '## Shrinking img file...'
    $SLEEPING
    debug 'INFO' "Using truncate to shrink img file to $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
    debug 'DEBUG' "Running: truncate --size=$TRUNCATE_TOTAL $IMG_FILE"
    if ! output=$(truncate --size="$TRUNCATE_TOTAL" "$IMG_FILE" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! TRUNCATE FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "TRUNCATE FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

    # Final check of img filesystem
    debug 'INFO' 'Finalizing filesystem'
    debug 'DEBUG' "Running do_e2fsck 'final'"
    do_e2fsck 'final'

  fi
return 0
}



# Function to rsync to img file
function do_rsync() {

  echo '## Backing up files...'
  $SLEEPING
  IMG_PATH=$(dirname "$IMG_FILE")
  debug 'DEBUG' "Backing up to ${IMG_PATH}${IMG_FILE}"
  debug 'INFO' 'Creating temporary file to store rsync output'
  debug 'DEBUG' 'Running: mktemp -t rsync-XXX'
  tmp_file=$(mktemp -t rsync-XXX)
  debug 'DEBUG' "tmp_file=$tmp_file"

  if [ "$EXCLUDE_FILE" = true ]; then
    debug 'DEBUG' "Running: rsync -ahvHAX --exclude-from=$(dirname $0)/exclude.txt --exclude={${IMG_PATH}/*,${TMP_DIR},${tmp_file}} --info=progress2 --stats "$RSYNC_DELETE" --force --partial --delete-excluded / $TMP_DIR"
    rsync -ahvHAX --exclude-from=$(dirname "$0")/exclude.txt --exclude={${IMG_PATH}/*,${TMP_DIR},${tmp_file}} --info=progress2 --stats "$RSYNC_DELETE" --force --partial --delete-excluded / "$TMP_DIR" 2>&1 | tee "$TTY_AVAILABILITY"  > "$tmp_file"
    # Get the exit status of rsync from PIPESTATUS
    if [ "${PIPESTATUS[0]}" -ne 0 ] && [ "${PIPESTATUS[0]}" -ne 23 ]; then # code 23 = rsync warning: some files vanished before they could be transferred (code 24) at main.c
      output=$(tail -16 "$tmp_file")
      echo -e "${Yellow}$output\n${Red}!! RSYNC FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "RSYNC FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    elif [ "${PIPESTATUS[0]}" -eq 23 ]; then
      debug 'WARNING' 'rsync code 23, some files vanished before they could be transferred (code 24) at main.c'
    fi
  else
    debug 'DEBUG' "Running: rsync -ahvHAX --exclude={/lost+found,/proc/*,/sys/*,/dev/*,/tmp/*,/run/*,/mnt/*,/media/*,/var/swap,${IMG_PATH}/*} --info=progress2 --stats "$RSYNC_DELETE" --force --partial --delete-excluded / $TMP_DIR"
    rsync -ahvHAX --exclude={/lost+found,/proc/*,/sys/*,/dev/*,/tmp/*,/run/*,/mnt/*,/media/*,/var/swap,${IMG_PATH}/*} --info=progress2 --stats "$RSYNC_DELETE" --force --partial --delete-excluded / "$TMP_DIR" 2>&1 | tee "$TTY_AVAILABILITY" > "$tmp_file"
    if [ "${PIPESTATUS[0]}" -ne 0 ] && [ "${PIPESTATUS[0]}" -ne 23 ]; then # code 23 = rsync warning: some files vanished before they could be transferred (code 24) at main.c
      output=$(tail -16 "$tmp_file")
      echo -e "${Yellow}$output\n${Red}!! RSYNC FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "RSYNC FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    elif [ "${PIPESTATUS[0]}" -eq 23 ]; then
      debug 'WARNING' 'rsync code 23, some files vanished before they could be transferred (code 24) at main.c'
    fi
  fi
  echo '## Rsync done...'
  echo '## Please stand by...'
  output=$(tail -16 "$tmp_file")
  debug 'BREAK'
  debug 'DEBUG' "Rsync report:\n$output\n------------------------------------------------------------------------------"
  debug 'INFO' 'Rsync done'
  sleep 4
return 0
}



# Function to create a backup img file
function make_img() {

  debug 'INFO' 'Running function: get_dev_variables'
  get_dev_variables

  # Display information
  if [ "$PROMPTS" = true ]; then
    echo ''
    echo '##############################################################################'
    echo -e "# ${Blue}A backup will be created at ${Green}$IMG_FILE${NC}"
    echo -e "# ${Green}$FSTYPE ${Blue}filesystem detected on root${NC}"
    if [ "$FSTYPE" == 'btrfs' ]; then
      echo -e "# ${Green}${#LOCAL_SUBVOLUMES[@]} ${Blue}btrfs volumes will be included${NC}"
      echo -e "# ${Blue}btrfs volumes: ${Green}${LOCAL_SUBVOLUMES[@]}${NC}"
    elif [ "$FSTYPE" == 'f2fs' ]; then
      echo -e "# ${Yellow}Autoexpand filesystem at boot not available for f2fs${NC}"
    elif [ "$F2FS" = true ]; then
      echo -e "# ${Yellow}Converting filesystem into f2fs on img file${NC}"
      echo -e "# ${Yellow}Autoexpand filesystem at boot not available for f2fs${NC}"
    fi
    echo '# ----------------------------------------------------------------------------'
    echo -e "# ${Blue}Write to logfile: ${Green}$DEBUG${NC}"
    echo -e "# ${Blue}Zoom speed requested: ${Green}$ZOOM${NC}"
    echo -e "# ${Blue}Autocalculate img root partition size: ${Green}$AUTORESIZE_RUN${NC}"
    echo -e "# ${Blue}Autoexpand filesystem at boot: ${Green}$AUTOEXPAND${NC}"
    echo -e "# ${Blue}Use exclude.txt: ${Green}$EXCLUDE_FILE${NC}"
    echo -e "# ${Blue}Bootsector size: ${Green}$(( LOCAL_BOOTSECTOR / 1024 / 1024 ))MiB${NC}"
    echo -e "# ${Blue}Estemated root usage: ${Green}$(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB${NC}"
    if [ "$AUTORESIZE_RUN" = true ]; then
      echo -e "# ${Blue}Auto calculated size (root partition): ${Green}$(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))MiB${NC}"
      echo -e "# ${Blue}Total img size: ${Green}$(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB${NC}"
    else
      echo -e "# ${Blue}Manually added space: ${Green}$(( ADDED_SPACE / 1024 / 1024 ))MiB${NC}"
      echo -e "# ${Blue}Total img size: ${Green}$(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB ${Blue}with ${Green}$(( ADDED_SPACE / 1024 / 1024 ))MiB ${Blue}extra space included.${NC}"
      if [ "$AUTORESIZE_WARNING" = true ]; then
        echo '# ----------------------------------------------------------------------------'
        echo -e "! ${Yellow}WARNING!!! Manually added space is smaller than calculated recommended minimum${NC}"
        echo -e "! ${Yellow}This does NOT mean the backup WILL fail, but CAN fail due to lack of space${NC}"
        echo -e "! ${Yellow}Consider using the -a option or manually adding more space${NC}"
        echo -e "# ${Blue}Requested root size:            ${Yellow}$(( TOTAL / 1024 / 1024 ))MiB${NC}"
        echo -e "# ${Blue}Calculated recommended minimum: ${Green}$(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))MiB${NC}"
      fi
    fi
    if [ "$F2FS" = true ]; then
      echo '# ----------------------------------------------------------------------------'
      echo -e "! ${Yellow}WARNING!!! --f2fs option selected. f2fs filesystem will be created on img file${NC}"
      echo -e "! ${Yellow}This option is only for CONVERTING existing filesystem into f2fs on img file${NC}"
      echo -e "! ${Yellow}This option is NOT needed for normal backups from f2fs on root${NC}"
      echo -e "# ${Blue}Only tested for Raspberry pi OS${NC}"
    fi
    echo '##############################################################################'

#     # Confirm with user input
#     read -p "Do you want to continue? [y/n] " -n 1 -r
#     debug 'INFO' 'Do you want to continue? [y/n]'
#     if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
#       echo ''
#       echo '## Aborting...'
#       exit 4
#     fi
#     echo ''
    debug 'INFO' 'Do you want to continue? [y/n]'
    while true; do
      read -n 1 -r -p '## Do you want to continue? [y/n] ' input
      case $input in
        [Yy]) echo -e '\n'; break;;
        [Nn]) echo -e "\n!! ${Red}Aborting...${NC}"; exit 4;;
        *) echo -e "\n!! ${Yellow}ERROR, please enter 'y/Y' or 'n/N'${NC}"; debug 'WARNING' "ERROR, please enter 'y/Y' or 'n/N'";;
      esac
    done
    debug 'INFO' 'Y or y pressed to confirm'
    debug 'BREAK'

    if test -f "$IMG_FILE"; then
      debug 'WARNING' "$IMG_FILE ALREADY EXISTS!"
      echo -e "!! ${Red}WARNING!!! WARNING!!! WARNING!!!${NC}"
      echo -e "!! ${Red}$IMG_FILE${NC}"
      echo -e "!! ${Red}FILE ALREADY EXISTS!!!${NC}"
      debug 'WARNING' 'Do you want to overwrite? [y/n]'
      while true; do
        read -n 1 -r -p '!! Do you want to overwrite? [y/n] ' input
        case $input in
          [Yy]) echo -e '\n'; break;;
          [Nn]) echo -e "\n!! ${Red}Aborting...${NC}"; exit 4;;
          *) echo -e "\n!! ${Yellow}ERROR, please enter 'y/Y' or 'n/N'${NC}"; debug 'WARNING' "ERROR, please enter 'y/Y' or 'n/N'";;
        esac
      done
      debug 'WARNING' 'Overwrite confirmed by user'
    fi

  else

    debug 'INFO' '-y selected by user. prompts are disabled'
    echo '##############################################################################'
    echo '# DISABLE PROMPTS SELECTED (-y), NO WARNINGS ABOUT DELETION!!!'
    echo "# A backup will be created at $IMG_FILE"
    echo "# $FSTYPE filesystem detected on root"
    if [ "$FSTYPE" == 'btrfs' ]; then
      echo "# ${#LOCAL_SUBVOLUMES[@]} btrfs volumes will be included"
      echo "# btrfs volumes: ${LOCAL_SUBVOLUMES[@]}"
    elif [ "$FSTYPE" == 'f2fs' ]; then
      echo '# Autoexpand filesystem at boot not available for f2fs'
    elif [ "$F2FS" = true ]; then
      echo '# Converting filesystem into f2fs on img file'
      echo '# Autoexpand filesystem at boot not available for f2fs'
    fi
    echo '# ----------------------------------------------------------------------------'
    echo "# Write to logfile: $DEBUG"
    echo "# Zoom speed requested: $ZOOM"
    echo "# Autocalculate img root partition size: $AUTORESIZE_RUN"
    echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "# Use exclude.txt: $EXCLUDE_FILE"
    echo "# Bootsector size: $(( LOCAL_BOOTSECTOR / 1024 / 1024 ))MiB"
    echo "# Estemated root usage: $(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB"
    if [ "$AUTORESIZE_RUN" = true ]; then
      echo "# Auto calculated size (root partition): $(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))MiB"
      echo "# Total img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
    else
      echo "# Manually added space: $(( ADDED_SPACE / 1024 / 1024 ))MiB"
      echo "# Total img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB with $(( ADDED_SPACE / 1024 / 1024 ))MiB extra space included."
      if [ "$AUTORESIZE_WARNING" = true ]; then
        echo '# ----------------------------------------------------------------------------'
        echo -e "! ${Red}WARNING!!! Manually added space is smaller than calculated recommended minimum${NC}"
        echo -e "! ${Red}This does NOT mean the backup WILL fail, but CAN fail due to lack of space"${NC}
        echo -e "! ${Red}Consider using the -a option or manually adding more space${NC}"
        echo -e "# ${Yellow}Requested root size:            ${Red}$(( TOTAL / 1024 / 1024 ))MiB${NC}"
        echo -e "# ${Yellow}Calculated recommended minimum: ${Red}$(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))MiB${NC}"
      fi
    fi
    if [ "$F2FS" = true ]; then
      echo '# ----------------------------------------------------------------------------'
      echo -e "! ${Yellow}WARNING!!! --f2fs option selected. f2fs filesystem will be created on img file${NC}"
      echo -e "! ${Yellow}This option is only for CONVERTING existing filesystem into f2fs on img file${NC}"
      echo -e "! ${Yeelow}This option is NOT needed for normal backups from f2fs on root${NC}"
      echo '# Only tested for Raspberry pi OS'
      echo '# ----------------------------------------------------------------------------'
    fi
    if [ "$ZOOM" = false ]; then
      echo -e "!! ${Red}PRESS CTRL+C WITHIN 5s TO CANCEL!${NC}"
      echo '##############################################################################'
      sleep 6
      debug 'INFO' '6 seconds passed, user did not stop operation'
      debug 'BREAK'
    fi
  fi

  # Delete existing file if user validation above passed
  if [ -f "$IMG_FILE" ]; then
    debug 'WARNING' "Removing: $IMG_FILE"
    echo -e "!! ${Yellow}Removing old img file...${NC}"
    rm "$IMG_FILE"
    $SLEEPING
  fi

  # Create and dd bootsector
  echo '## Creating bootsector...'
  $SLEEPING
  debug 'INFO' 'Using dd to create bootsector'
  #if ! output=$(dd bs=512 count=$LOCAL_DDBOOTSECTOR if="$LOCAL_DEV_PATH" of="$IMG_FILE" conv=noerror,sync status=progress 2>&1 | tee "$TTY_AVAILABILITY"); then
  if ! output=$(dd bs=512 count=$LOCAL_DDBOOTSECTOR if="$LOCAL_DEV_PATH" of="$IMG_FILE" conv=noerror,sync status=progress 2>&1 | tee "$TTY_AVAILABILITY"); then
  #if ! output=$(dd bs=512 count=$LOCAL_DDBOOTSECTOR if="$LOCAL_DEV_PATH" of="$IMG_FILE" conv=noerror,sync status=progress 2>&1 | exec &> >(tee >(test -z /dev/tty && /dev/null) >&2)); then
    echo -e "${Yellow}$output\n${Red}!! DD TO LOCAL_BOOTSECTOR FAILED!!!${NC}"
    debug 'BREAK'
    debug 'ERROR' "DD TO LOCAL_BOOTSECTOR FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  output=$(echo "$output" | tail -3 )
  debug 'BREAK'
  debug 'DEBUG' "Running: dd bs=512 count=$LOCAL_DDBOOTSECTOR if=$LOCAL_DEV_PATH of=$IMG_FILE conv=noerror,sync status=progress\n$output\n------------------------------------------------------------------------------"
  $SLEEPING

  # Truncate file to correct size
  echo "## Resizing img file..."
  $SLEEPING
  debug 'INFO' "Using truncate to resize img file to $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
  debug 'DEBUG' "Running: truncate --size=$TRUNCATE_TOTAL $IMG_FILE"
  if ! output=$(truncate --size="$TRUNCATE_TOTAL" "$IMG_FILE" 2>&1); then
    echo -e "${Yellow}$output\n${Red}!! TRUNCATE FAILED!!!${NC}"
    debug 'BREAK'
    debug 'ERROR' "TRUNCATE FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  $SLEEPING

  # Loop img file
  debug 'DEBUG' 'Running function: do_loop'
  do_loop

  # set img variables
  debug 'INFO' 'Running function: set_img_variables'
  set_img_variables

  # Remove partition
  echo '## Removing root partition...'
  $SLEEPING

  # GPT
  if [ $PARTITION_TABLE == 'gpt' ]; then
    echo '## GPT partition table detected, sgdisk needed, checking for application...'
    $SLEEPING
    if [[ ! -f $(which sgdisk 2>&1) ]]; then
      echo '## sgdisk is NOT installed...'
      debug 'INFO' 'sgdisk not available on system'
      read -p "Do you want to try to install gdisk? [y/n] " -n 1 -r
      debug 'INFO' 'Do you want to try to install gdisk? [y/n]'
      if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
        echo ''
        echo '## Aborting...'
        exit 5
      fi
      echo ''
      debug 'INFO' 'Y or y pressed to confirm'
      if [[ -f $(which apt 2>&1) ]]; then
        echo '## apt found, trying to install gdisk...'
        read -p "Do you want to use apt to install gdisk? [y/n] " -n 1 -r
        debug 'INFO' 'Do you want to use apt to install gdisk? [y/n]'
        if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
          echo ''
          echo '## Aborting...'
          exit 5
        fi
        echo ''
        debug 'INFO' 'Y or y pressed to confirm'
        debug 'DEBUG' 'Running: apt update -y && apt upgrade -y && apt install gdisk -y'
        $SLEEPING
        apt update -y && apt upgrade -y && apt install gdisk -y
      elif [[ -f $(which pacman 2>&1) ]]; then
        echo '## pacman found, trying to install gdisk...'
        read -p "Do you want to use pacman to install gptfdisk? (will do -Syu first) [y/n] " -n 1 -r
        debug 'INFO' 'Do you want to use apt to install gptfdisk? (will do -Syu first) [y/n]'
        if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
          echo ''
          echo '## Aborting...'
          exit 5
        fi
        echo ''
        debug 'INFO' 'Y or y pressed to confirm'
        debug 'DEBUG' 'Running: pacman -Syu && pacman -S gptfdisk'
        $SLEEPING
        pacman -Syu && pacman -S gptfdisk
      else
        echo '## Installing gdisk failed, please install gdisk manually and retry script...'
        debug 'ERROR' 'Installing gdisk failed, aborting exit 1'
        echo '## Aborting...'
        exit 1
      fi
      echo '## gdisk installed successfully, resuming backup...'
      debug 'INFO' 'gdisk installed successfully'
      $SLEEPING

    else
      echo '## sgdisk is available, resuming backup...'
      debug 'INFO' 'sgdisk is available on system'
      $SLEEPING
    fi

    debug 'INFO' 'Using sgdisk to remove root partition'
    debug 'DEBUG' "Running: sgdisk $LOOP -d $LOCAL_ROOT_PARTN"
    if ! output=$(sgdisk "$LOOP" -d "$LOCAL_ROOT_PARTN" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! SGDISK FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "SGDISK FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

  # MBR
  else
    # keep all of this for memory, things needed to get this to work seems to change back and forth over time
    debug 'INFO' 'Using sfdisk to remove root partition'
    #debug 'INFO' 'Using parted to remove root partition'
    debug 'DEBUG' "Running: sfdisk --delete -f $LOOP $LOCAL_ROOT_PARTN"
    #debug 'DEBUG' "Running: parted -s $LOOP rm $LOCAL_ROOT_PARTN"
    #debug 'DEBUG' "Running: printf 'Ignore\\\n'$LOCAL_ROOT_PARTN | parted $LOOP rm $LOCAL_ROOT_PARTN ---pretend-input-tty"

    if ! output=$(sfdisk --delete -f "$LOOP" "$LOCAL_ROOT_PARTN" 2>&1); then # might fail if img size is very big
    #if ! output=$(parted -s "$LOOP" rm "$LOCAL_ROOT_PARTN" 2>&1); then # retry this after -f got removed, before = does not work, still asking for user confirmation even though --script and -f (automatically answer "fix" to exceptions in script mode) is used. faults with: "Error: Can't have a partition outside the disk!". for some reason this line works in the resizing function
    #if ! output=$(printf 'Ignore\n'$LOCAL_ROOT_PARTN | parted $LOOP rm $LOCAL_ROOT_PARTN ---pretend-input-tty 2>&1); then # raspberry pi os does not like this method, keep for memory
      echo -e "${Yellow}$output\n${Red}!! SFDISK FAILED!!!${NC}"
      #echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "SFDISK FAILED:\n$output\n------------------------------------------------------------------------------"
      #debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  fi
  $SLEEPING

  # Recreate partition
  echo '## Recreating root partition...'
  $SLEEPING
  debug 'INFO' 'Using parted to recreate root partition'

  # Convert to f2fs
  if [ "$F2FS" = true ]; then
    debug 'INFO' '--f2fs selected by user, creating f2fs partition on img file'
    debug 'DEBUG' "Running: parted -s -a none $LOOP unit B mkpart primary f2fs $LOCAL_ROOT_START 100%"
    if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary f2fs "$LOCAL_ROOT_START" 100% 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

  # ext4 & f2fs on root
  elif [ "$FSTYPE" == 'ext4' ] || [ "$FSTYPE" == 'f2fs' ]; then
    debug 'DEBUG' "Running: parted -s -a none $LOOP unit B mkpart primary $FSTYPE $LOCAL_ROOT_START 100%"
    #if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary "$FSTYPE" "$LOCAL_ROOT_START" 100% 2>&1); then
    if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary "$LOCAL_ROOT_START" 100% 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi

  # btrfs
  else
    debug 'DEBUG' "Running: parted -s -a none $LOOP unit B mkpart primary btrfs $LOCAL_ROOT_START 100%"
    if ! output=$(parted -s -a none "$LOOP" unit B mkpart primary btrfs "$LOCAL_ROOT_START" 100% 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! PARTED FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  fi
  $SLEEPING

  # Format filesystem
  echo '## Formatting filesystem...'
  debug 'INFO' 'Formatting filesystem'
  $SLEEPING
  LABEL=$(lsblk -o label "$LOCAL_DEV_ROOT_PATH" | tail -1)
  UUID=$(lsblk -o uuid "$LOCAL_DEV_ROOT_PATH" | tail -1)
  debug 'DEBUG' "LABEL=$LABEL | UUID=$UUID"

  # Convert to f2fs
  if [ "$F2FS" = true ]; then
    echo '## --f2fs option selected, mkfs.f2fs is needed, checking if installed...'
    $SLEEPING
    if [[ ! -f $(which mkfs.f2fs 2>&1) ]]; then
      echo '## mkfs.f2fs is NOT installed...'
      debug 'INFO' 'mkfs.f2fs (f2fs-tools) not available on system'
      read -p "Do you want to use apt to install f2fs-tools? [y/n] " -n 1 -r
      debug 'INFO' 'Do you want to try to install f2fs-tools? [y/n]'
      if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
        echo ''
        echo '## Aborting...'
        exit 5
      fi
      echo ''
      debug 'INFO' 'Y or y pressed to confirm'
      debug 'DEBUG' 'Running: apt update -y && apt upgrade -y && apt install f2fs-tools -y'
      $SLEEPING
      apt update -y && apt upgrade -y && apt install f2fs-tools -y
      $SLEEPING

    else
      echo '## mkfs.f2fs is available, resuming backup...'
      debug 'INFO' 'mkfs.f2fs is available on system'
      $SLEEPING
    fi

    debug 'DEBUG' "Running: mkfs.f2fs -f -U $UUID -l $LABEL $IMG_DEV_ROOT_PATH"
    if ! output=$(mkfs.f2fs -f -U "$UUID" -l "$LABEL" "$IMG_DEV_ROOT_PATH" 2>&1 | tee "$TTY_AVAILABILITY" ); then
      echo -e "${Yellow}$output\n${Red}!! MKFS.F2FS FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "MKFS.F2FS FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'BREAK'
    debug 'DEBUG' "Running: mkfs.f2fs -f -U $UUID -l $LABEL $IMG_DEV_ROOT_PATH\n$output\n------------------------------------------------------------------------------"
    $SLEEPING

    debug 'INFO' 'Running function: do_mount'
    do_mount

  # ext4
  elif [ "$FSTYPE" == 'ext4' ]; then
    debug 'INFO' "Using mkfs.ext4 to format root filesystem"
    if ! output=$(mkfs.ext4 -U "$UUID" -L "$LABEL" "$IMG_DEV_ROOT_PATH" 2>&1 | tee "$TTY_AVAILABILITY" ); then
      echo -e "${Yellow}$output\n${Red}!! MKFS.EXT4 FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "MKFS.EXT4 FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'BREAK'
    debug 'DEBUG' "Running: mkfs.$FSTYPE -U $UUID -L $LABEL $IMG_DEV_ROOT_PATH\n$output\n------------------------------------------------------------------------------"
    $SLEEPING

    debug 'INFO' 'Running function: do_e2fsck'
    do_e2fsck

    debug 'INFO' 'Running function: do_mount'
    do_mount

  # f2fs
  elif [ "$FSTYPE" == 'f2fs' ]; then
    debug 'INFO' "Using mkfs.f2fs to format root filesystem"
    if ! output=$(mkfs.f2fs -f -U "$UUID" -l "$LABEL" "$IMG_DEV_ROOT_PATH" 2>&1 | tee "$TTY_AVAILABILITY" ); then
      echo -e "${Yellow}$output\n${Red}!! MKFS.F2FS FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "MKFS.F2FS FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'BREAK'
    debug 'DEBUG' "Running: mkfs.f2fs -f -U $UUID -l $LABEL $IMG_DEV_ROOT_PATH\n$output\n------------------------------------------------------------------------------"
    $SLEEPING

    debug 'INFO' 'Running function: do_mount'
    do_mount

  # btrfs
  elif [ "$FSTYPE" == 'btrfs' ]; then
    debug 'INFO' 'Using mkfs.btrfs to format root filesystem'
    partprobe "$LOOP"
    if ! output=$(mkfs.btrfs -f -m single -L "$LABEL" -v "$IMG_DEV_ROOT_PATH" 2>&1 | tee "$TTY_AVAILABILITY" ); then # btrfs does NOT like having the same uuid on 2 filesystems at the same time
      echo -e "${Yellow}$output\n${Red}!! MKFS.BTRFS FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "MKFS.BTRFS FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'BREAK'
    debug 'DEBUG' "Running: mkfs.btrfs -f -m single -L $LABEL -v $IMG_DEV_ROOT_PATH\n$output\n------------------------------------------------------------------------------"
    $SLEEPING

    # Check for temp directory and create if needed
    if ! [ -d "$TMP_DIR" ]; then
      echo '## Creating temp directory...'
      $SLEEPING
      debug 'INFO' 'Creating temp directory'
      debug 'DEBUG' "Running: mktemp -d -t backup-XXX"
      TMP_DIR=$(mktemp -d -t backup-XXX)
      debug 'DEBUG' "TMP_DIR=$TMP_DIR"
    fi

    echo '## Creating btrfs subvolumes...'
    debug 'INFO' 'Creating btrfs subvolumes'
    debug 'DEBUG' "Running: mount -o compress=zstd $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount -o noatime,compress=zstd "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! ROOT MOUNT FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "ROOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    $SLEEPING

    # Create top subvolumes, ${#LOCAL_SUBVOLUMES[@]} gives count
    for ((i = 0; i < ${#LOCAL_SUBVOLUMES[@]}; i++)); do
      subvol_path="${LOCAL_SUBVOLUMES[i]}"
      if [[ "$subvol_path" == '@'* ]]; then
        echo "## Creating subvolume: $subvol_path"
        debug 'DEBUG' "Running: btrfs subvolume create ${TMP_DIR}/${subvol_path}"
        if ! output=$(btrfs subvolume create "$TMP_DIR"/"$subvol_path" 2>&1); then
          echo -e "${Yellow}$output\n${Red}!! CREATE SUBVOLUME FAILED!!!${NC}"
          debug 'BREAK'
          debug 'ERROR' "CREATE SUBVOLUME FAILED:\n$output\n------------------------------------------------------------------------------"
          exit 1
        fi
      fi
      $SLEEPING
    done

    echo '## Mounting root...'
    debug 'INFO' 'Unmounting btrfs filesystem & mounting root subvolume'
    debug 'DEBUG' "Running: umount $TMP_DIR"
    umount "$TMP_DIR"
    $SLEEPING
    partprobe "$LOOP"
    #fstab=( $(cat /etc/fstab | grep "${LOCAL_SUBVOLUMES[0]}") )
    declare -a fstab=( $(cat /etc/fstab | grep '/ ') )
    debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH $TMP_DIR"
    if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" "$TMP_DIR" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! ROOT SUBVOLUME MOUNT FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "ROOT SUBVOLUME MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    $SLEEPING

    # Create nested volumes/snapshots
    debug 'INFO' 'Creating nested volumes/snapshots'
    for ((i = 0; i < ${#LOCAL_SUBVOLUMES[@]}; i++)); do
      subvol_path="${LOCAL_SUBVOLUMES[i]}"
      if [[ "$subvol_path" != '@'* ]]; then
        debug 'DEBUG' "Running: mkdir -p $TMP_DIR/$(dirname $subvol_path)"
        mkdir -p $TMP_DIR/$(dirname $subvol_path)

        echo "## Creating volume: $subvol_path"
        debug 'DEBUG' "Running: btrfs subvolume create ${TMP_DIR}/${subvol_path}"
        if ! output=$(btrfs subvolume create "$TMP_DIR"/"$subvol_path" 2>&1); then
          echo -e "${Yellow}$output\n${Red}!! CREATE VOLUME FAILED!!!${NC}"
          debug 'BREAK'
          debug 'ERROR' "CREATE VOLUME FAILED:\n$output\n------------------------------------------------------------------------------"
          exit 1
        fi
      fi
      $SLEEPING
    done

    echo '## Mounting img btrfs volumes...'
    debug 'INFO' 'Mounting volumes'
    $SLEEPING
    partprobe "$LOOP"

    for ((i = 0; i < ${#LOCAL_SUBVOLUMES[@]}; i++)); do
      subvol_path="${LOCAL_SUBVOLUMES[i]}"
      if grep -q "$subvol_path" /etc/fstab && [[ "$subvol_path" != '@' ]]; then
        declare -a fstab=( $(cat /etc/fstab | grep "$subvol_path") )
        debug 'DEBUG' "Running: mkdir -p ${TMP_DIR}${fstab[1]}"
        mkdir -p ${TMP_DIR}${fstab[1]}
        echo "## Mounting subvolume: $subvol_path"
        debug 'DEBUG' "Running: mount -o ${fstab[3]} $IMG_DEV_ROOT_PATH ${TMP_DIR}${fstab[1]}"
        if ! output=$(mount -o "${fstab[3]}" "$IMG_DEV_ROOT_PATH" ${TMP_DIR}${fstab[1]} 2>&1); then
          echo -e "${Yellow}$output\n${Red}!! VOLUME MOUNT FAILED!!!${NC}"
          debug 'BREAK'
          debug 'ERROR' "VOLUME MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
          exit 1
        fi
      fi
      $SLEEPING
    done

    echo '## Mounting boot...'
    debug 'DEBUG' "Running: mount $IMG_DEV_BOOT_PATH ${TMP_DIR}${BOOT_PATH}"
    mkdir -p ${TMP_DIR}${BOOT_PATH}
    if ! output=$(mount "$IMG_DEV_BOOT_PATH" "${TMP_DIR}${BOOT_PATH}" 2>&1); then
      echo -e "${Yellow}$output\n${Red}!! BOOT MOUNT FAILED!!!${NC}"
      debug 'BREAK'
      debug 'ERROR' "BOOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    $SLEEPING
  fi

  # Copy files
  debug 'INFO' 'Backing up files'
  debug 'INFO' 'Running function: do_rsync'
  do_rsync

  # Editing fstab and cmdline.txt on img file for f2fs conversion
  if [ "$F2FS" = true ]; then
    echo '## Editing img configurations for f2fs...'
    debug 'INFO' 'Configuring fstab and cmdline.txt on img file for f2fs'

    # fstab
    debug 'INFO' 'Backing up fstab & cmdline.txt into fstab.shrink-backup.bak & cmdline.shrink-backup.bak on img'
    cp ${TMP_DIR}/etc/fstab ${TMP_DIR}/etc/fstab.shrink-backup.bak
    cp ${TMP_DIR}${BOOT_PATH}/cmdline.txt ${TMP_DIR}${BOOT_PATH}/cmdline.txt.shrink-backup.bak
    debug 'DEBUG' "Old root line in fstab=$(cat ${TMP_DIR}/etc/fstab | grep ' / ')"
    fstab_options=$(cat ${TMP_DIR}/etc/fstab | grep ' / ' | awk '{print $4}')
    debug 'DEBUG' "Running: sed -i -e \"/${LOCAL_ROOT_PARTUUID}/s/ext4/f2fs/\" -e \"/${LOCAL_ROOT_PARTUUID}/s/${fstab_options}/${fstab_options},discard/\" ${TMP_DIR}/etc/fstab"
    sed -i -e "/${LOCAL_ROOT_PARTUUID}/s/ext4/f2fs/" -e "/$LOCAL_ROOT_PARTUUID/s/${fstab_options}/${fstab_options},discard/" ${TMP_DIR}/etc/fstab
    debug 'DEBUG' "New root line in fstab=$(cat ${TMP_DIR}/etc/fstab | grep ' / ')"

    # cmdline.txt
    debug 'INFO' "Old line in cmdline.txt: $(cat ${TMP_DIR}${BOOT_PATH}/cmdline.txt | grep 'console')"
    debug 'DEBUG' "Running: sed -i 's/rootfstype=ext4/rootfstype=f2fs/' ${TMP_DIR}${BOOT_PATH}/cmdline.txt"
    sed -i 's/rootfstype=ext4/rootfstype=f2fs/' "${TMP_DIR}${BOOT_PATH}"/cmdline.txt
    debug 'DEBUG' "New line in cmdline.txt: $(cat ${TMP_DIR}${BOOT_PATH}/cmdline.txt | grep 'console')"
  fi

  # Final check of created img file
  if [ "$FSTYPE" == 'ext4' ] && [ "$F2FS" = false ]; then
    debug 'INFO' "Running do_e2fsck 'final'"
    do_e2fsck 'final'
  fi

return 0
}



# Function to update existing img file
function do_backup() {

  # Making sure img file exists
  if ! [ -f "$IMG_FILE" ]; then
    echo "## ERROR. $IMG_FILE does not exist!"
    debug 'ERROR' "$IMG_FILE does not exist, exit 1"
    exit 1
  fi

  debug 'INFO' 'Running function: get_dev_variables'
  # get_btrfs_variables is run within get_dev_variables
  get_dev_variables

  debug 'INFO' 'Running function: do_loop'
  do_loop

  debug 'INFO' 'Running function: get_img_variables'
  get_img_variables

  # Checking if resizing should be performed
  if [ "$AUTORESIZE_RUN" = true ]; then
    debug 'DEBUG' "Running: fdisk --bytes -lo device,size "$LOOP" | grep "$IMG_DEV_ROOT_PATH" | awk '{print \$2}'"
    IMG_ROOT_SIZE=$(fdisk --bytes -lo device,size "$LOOP" | grep "$IMG_DEV_ROOT_PATH" | awk '{print $2}' )
    diff=$(( (LOCAL_AUTORESIZE_MIN - IMG_ROOT_SIZE) / 1024 / 1024 ))
    debug 'DEBUG' "IMG_ROOT_SIZE=$IMG_ROOT_SIZE bytes | LOCAL_AUTORESIZE_MIN=$LOCAL_AUTORESIZE_MIN bytes | diff=${diff}MiB"

    if [ "$IMG_ROOT_SIZE" -lt "$LOCAL_AUTORESIZE_MIN" ] && (( LOCAL_AUTORESIZE_MIN - IMG_ROOT_SIZE >= 268435456 )); then # 256MiB in bytes
      DIFFERENCE="${diff}MiB, Expanding img filesystem"
      RESIZE_FUNCTION='expand'
    elif [ "$IMG_ROOT_SIZE" -gt "$LOCAL_AUTORESIZE_MIN" ] && (( IMG_ROOT_SIZE - LOCAL_AUTORESIZE_MIN >= 536870912 )); then # 512MiB in bytes
      DIFFERENCE="${diff}MiB, Shrinking img filesystem"
      RESIZE_FUNCTION='shrink'
    else
      if [ "$diff" != -* ]; then
        DIFFERENCE="Too small (${diff}MiB), not shrinking filesystem (must be >=512MiB)"
      else
        DIFFERENCE="Too small (${diff}MiB), not expanding filesystem (must be >=256MiB)"
      fi
    fi
  # Change TRUNCATE_TOTAL to be based on img file instead of local root if [extra space] is provided
  elif [ "$ADDED_SPACE" -ne 0 ]; then
    debug 'INFO' 'Manually added space provided by user, calculating img size (TRUNCATE_TOTAL) by adding ADDED_SPACE to IMG_SIZE'
    TRUNCATE_TOTAL=$(( ADDED_SPACE + IMG_SIZE ))
    debug 'DEBUG' "TRUNCATE_TOTAL=${TRUNCATE_TOTAL} bytes"
  fi

  # Display information
  if [ "$PROMPTS" = true ]; then
    echo '##############################################################################'
    echo "# Updating $IMG_FILE"
    echo "# $FSTYPE filesystem detected on root"
    if [ "$FSTYPE" == 'btrfs' ]; then
      echo '# btrfs filesystem detected on root'
      echo "# ${#LOCAL_SUBVOLUMES[@]} btrfs volumes will be included"
      echo "# btrfs volumes: ${LOCAL_SUBVOLUMES[@]}"
    elif [ "$FSTYPE" == 'f2fs' ]; then
      echo '# Autoexpand filesystem at boot not available for f2fs'
      echo '# Resize operations not available for f2fs'
    fi
    if [ "$RSYNC_DELETE" = '--delete-before' ]; then
      echo '# --fix option selected, rsync will delete files on img before copy'
      debug 'DEBUG' '--fix option selected by user, rsync deleting files before copy'
    fi
    echo '# ----------------------------------------------------------------------------'
    echo "# Write to logfile: $DEBUG"
    echo "# Zoom speed requested: $ZOOM"
    echo "# Autocalculate img root partition size: $AUTORESIZE_RUN"
    echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "# Use exclude.txt: $EXCLUDE_FILE"
    echo "# Bootsector size: $(( LOCAL_BOOTSECTOR / 1024 / 1024 ))MiB"
    if [ "$AUTORESIZE_RUN" = true ]; then
      echo "# Auto calculated size (root partition): $(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))MiB"
      echo "# Old img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
      echo "# New img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
      echo "# Difference: $DIFFERENCE"
    elif [ "$ADDED_SPACE" -ne 0 ]; then
      echo "# Estemated root usage: $(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB"
      echo "# Old img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
      echo "# New img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
      echo "# Difference: $(( ADDED_SPACE / 1024 / 1024 ))MiB"
    else
      echo "# Estemated root usage: $(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB"
      echo "# Total img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
    fi
    echo '##############################################################################'

    # Confirm with user input
    debug 'INFO' 'Do you want to continue? [y/n]'
    while true; do
      read -n 1 -r -p '## Do you want to continue? [y/n] ' input
      case $input in
        [Yy]) echo -e '\n'; break;;
        [Nn]) echo -e "\n!! ${Red}Aborting...${NC}"; exit 4;;
        *) echo -e "\n!! ${Yellow}ERROR, please enter 'y/Y' or 'n/N'${NC}"; debug 'WARNING' "ERROR, please enter 'y/Y' or 'n/N'";;
      esac
    done
    debug 'INFO' 'Y or y pressed to confirm'
    debug 'BREAK'

  else

    echo '##############################################################################'
    echo '# DISABLE PROMPTS SELECTED'
    echo "# Updating $IMG_FILE"
    echo "# $FSTYPE filesystem detected on root"
    if [ "$FSTYPE" == 'btrfs' ]; then
      echo '# btrfs filesystem detected on root'
      echo "# ${#LOCAL_SUBVOLUMES[@]} btrfs volumes will be included"
      echo "# btrfs volumes: ${LOCAL_SUBVOLUMES[@]}"
    elif [ "$FSTYPE" == 'f2fs' ]; then
      echo '# Autoexpand filesystem at boot not available for f2fs'
      echo '# Resize operations not available for f2fs'
    fi
    if [ "$RSYNC_DELETE" = '--delete-before' ]; then
      echo '# --fix option selected, rsync will delete files on img before copy'
      debug 'DEBUG' '--fix option selected by user, rsync deleting files before copy'
    fi
    echo '# ----------------------------------------------------------------------------'
    echo "# Write to logfile: $DEBUG"
    echo "# Zoom speed requested: $ZOOM"
    echo "# Autocalculate img root partition size: $AUTORESIZE_RUN"
    echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "# Use exclude.txt: $EXCLUDE_FILE"
    echo "# Bootsector size: $(( LOCAL_BOOTSECTOR / 1024 / 1024 ))MiB"
    if [ "$AUTORESIZE_RUN" = true ]; then
      echo "# Auto calculated size (root partition): $(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))MiB"
      echo "# Old img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
      echo "# New img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
      echo "# Difference: $DIFFERENCE"
    elif [ "$ADDED_SPACE" -ne 0 ]; then
      echo "# Estemated root usage: $(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB"
      echo "# Old img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
      echo "# New img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MiB"
      echo "# Difference: $(( ADDED_SPACE / 1024 / 1024 ))MiB"
    else
      echo "# Estemated root usage: $(( $(df / -k --sync --output=used | tail -1) / 1024 ))MiB"
      echo "# Total img size: $(( IMG_SIZE / 1024 / 1024 ))MiB"
    fi
    if [ "$ZOOM" = false ]; then
      echo -e "!! ${Red}PRESS CTRL+C WITHIN 5s TO CANCEL!${NC}"
      echo '##############################################################################'
      sleep 6
      debug 'INFO' '6 seconds passed, user did not stop operation'
      debug 'BREAK'
    fi
  fi

  # Resizing if needed
  if [ "$AUTORESIZE_RUN" = true ]; then
    # Expanding
    if [ "$RESIZE_FUNCTION" = 'expand' ]; then
      debug 'INFO' 'Img root partition size is smaller than auto calculated size'
      debug 'DEBUG' "Difference=$diff MiB"
      debug 'INFO' "Running function: do_resize 'expand'"
      do_resize 'expand'

    # Shrinking
    elif [ "$RESIZE_FUNCTION" = 'shrink' ]; then
      debug 'INFO' 'Img root partition size is bigger than auto calculated size'
      debug 'DEBUG' "diff=${diff}MiB"
      debug 'INFO' 'Running function: do_mount'
      do_mount
      debug 'INFO' 'Backing up files'
      debug 'INFO' 'Running function: do_rsync'
      do_rsync
      debug 'INFO' 'Shrinking img filesystem'
      debug 'INFO' "Running function: do_resize 'shrink'"
      do_resize 'shrink'
      return 0

    else
      debug 'INFO' 'Img root partition is <=256MiB smaller or <=512MiB bigger compared to auto calculated size, not resizing'
      $SLEEPING
    fi
  fi

  # Expand img file if ADDED_SPACE not 0
  if [ "$ADDED_SPACE" -ne 0 ]; then
    debug 'INFO' "Running function: do_resize 'expand'"
    do_resize 'expand'
  fi

  debug 'INFO' 'Running function: do_mount'
  do_mount
  debug 'INFO' 'Backing up files'
  debug 'INFO' 'Running function: do_rsync'
  do_rsync

  if [ $FSTYPE == 'ext4' ]; then
    # Final check of created img file
    debug 'INFO' "Running do_e2fsck 'final'"
    do_e2fsck 'final'
  fi

return 0
}



# Enabling autoexpansion for Manjaro
function autoexpansion_manjaro() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.target.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi

  # Creating autoexpansion systemd unit file expand-fs.service
  debug 'DEBUG' 'Systemd unit expand-fs.service does not exist, creating it'
  cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c "/usr/bin/resize-fs || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service && /usr/bin/rm /etc/systemd/system/expand-fs.service && /usr/bin/reboot -f || exit 0"

[Install]
WantedBy=basic.target
EOF

  if ! [ -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi

  echo '## Manjaro filesystem autoresizing at boot...'
  debug 'INFO' 'Manjaro filesystem autoresizing at boot'
  $SLEEPING
return 0
}



# Enabling autoexpansion for Armbian
function autoexpansion_armbian() {
  if ! test -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service"; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /lib/systemd/system/armbian-resize-filesystem.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service"
    ln -s /lib/systemd/system/armbian-resize-filesystem.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service
  fi
  echo '## Armbian filesystem autoresizing at boot...'
  debug 'INFO' 'Armbian filesystem autoresizing at boot'
  $SLEEPING
return 0
}



# Enabling autoexpansion for Raspberry pi
function autoexpansion_rpi() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.target.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi

  # Creating autoexpansion systemd unit file expand-fs.service
  debug 'DEBUG' 'Creating systemd unit expand-fs.service'
  cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c "/expand-fs.sh || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service && /usr/bin/rm /expand-fs.sh && /usr/bin/rm /etc/systemd/system/expand-fs.service && /usr/sbin/reboot -f || exit 0"

[Install]
WantedBy=basic.target
EOF

  if ! [ -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi

  # Creating script for autoexpansion
  debug 'DEBUG' "Creating expansion script ${TMP_DIR}/expand-fs.sh"
  cat << EOF2 > "${TMP_DIR}/expand-fs.sh"
#!/usr/bin/bash
LOCAL_DEV_PTUUID=\$(lsblk -lpo mountpoint,ptuuid | grep '/ ' | awk '{print \$2}')
LOCAL_DEV_PATH=\$(lsblk -lpo ptuuid,type,path | grep "\$LOCAL_DEV_PTUUID" | grep 'disk' | awk '{print \$3}')
LOCAL_ROOT_PARTN=\$(parted -sm "\$LOCAL_DEV_PATH" print | tail -1 | cut -d : -f 1)
LOCAL_DEV_ROOT_PATH=\$(lsblk -lpo mountpoint,path | grep '/ ' | awk '{print \$2}')
LOCAL_ROOT_START=\$(fdisk -lo start "\$LOCAL_DEV_PATH" | tail -1 | awk '{print \$1}') # blocks, 512B block size
LOCAL_ROOT_START=\$(( LOCAL_ROOT_START * 512 )) # bytes

sfdisk --delete -f "\$LOCAL_DEV_PATH" "\$LOCAL_ROOT_PARTN"
parted -s -a none "\$LOCAL_DEV_PATH" unit B mkpart primary "\$LOCAL_ROOT_START" 100%

resize2fs -f "\$LOCAL_DEV_ROOT_PATH"
sync
exit 0
EOF2

  debug 'DEBUG' 'Making expand-fs.sh executable'
  chmod +x ${TMP_DIR}/expand-fs.sh

  echo '## Raspberry pi filesystem autoresizing at boot...'
  debug 'INFO' 'Raspberry pi filesystem autoresizing at boot'
  $SLEEPING
return 0
}



# Enabling autoexpansion for ArchLinuxArm
function autoexpansion_arch() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.target.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi

  # Creating autoexpansion systemd unit file expand-fs.service
  debug 'DEBUG' 'Creating systemd unit expand-fs.service'
  cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c "/expand-fs.sh || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service && /usr/bin/rm /expand-fs.sh && /usr/bin/rm /etc/systemd/system/expand-fs.service && /usr/bin/reboot -f || exit 0"

[Install]
WantedBy=basic.target
EOF

  if ! [ -L "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi

  # Creating script for autoexpansion
  debug 'DEBUG' 'Creating expansion script ${TMP_DIR}/expand-fs.sh'
  cat << EOF2 > "${TMP_DIR}/expand-fs.sh"
#!/usr/bin/bash
LOCAL_DEV_PTUUID=\$(lsblk -lpo mountpoint,ptuuid | grep '/ ' | awk '{print \$2}')
LOCAL_DEV_PATH=\$(lsblk -lpo ptuuid,type,path | grep "\$LOCAL_DEV_PTUUID" | grep 'disk' | awk '{print \$3}')
LOCAL_ROOT_PARTN=\$(parted -sm "\$LOCAL_DEV_PATH" print | tail -1 | cut -d : -f 1)
LOCAL_DEV_ROOT_PATH=\$(lsblk -lpo mountpoint,path | grep '/ ' | awk '{print \$2}')
LOCAL_ROOT_START=\$(fdisk -lo start "\$LOCAL_DEV_PATH" | tail -1 | awk '{print \$1}') # blocks, 512B block size
LOCAL_ROOT_START=\$(( LOCAL_ROOT_START * 512 )) # bytes

sfdisk --delete -f "\$LOCAL_DEV_PATH" "\$LOCAL_ROOT_PARTN"
parted -s -a none "\$LOCAL_DEV_PATH" unit B mkpart primary "\$LOCAL_ROOT_START" 100%
resize2fs -f "\$LOCAL_DEV_ROOT_PATH"
sync
exit 0
EOF2

  debug 'DEBUG' 'Making /expand-fs.sh executable'
  chmod +x ${TMP_DIR}/expand-fs.sh

  echo '## ArchLinuxArm filesystem autoresizing at boot...'
  debug 'INFO' 'ArchLinuxArm filesystem autoresizing at boot'
  $SLEEPING
return 0
}



# Function to print result
function print_result() {

  declare -i AFTER_SIZE=$(ls -l "$IMG_FILE" | cut -d ' ' -f 5)
  AFTER_SIZE=$(( AFTER_SIZE / 1024 / 1024 ))

  if [ "$UPDATE" != true ]; then
    echo -e "## ${Green}Backup done.${NC}"
    echo '##############################################################################'
    echo "## Write to logfile: $DEBUG"
    echo "## Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "## Use exclude.txt: $EXCLUDE_FILE"
    if [ "$AUTORESIZE_RUN" = true ]; then
      echo "## $IMG_FILE is ${AFTER_SIZE}MiB with a root partition of $(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))MiB."
      debug 'INFO' "$IMG_FILE is ${AFTER_SIZE}MiB with a root partition of $(( LOCAL_AUTORESIZE_MIN / 1024 / 1024 ))MiB"
    else
      echo "## $IMG_FILE is ${AFTER_SIZE}MiB with $(( ADDED_SPACE / 1024 / 1024 ))MiB extra space included."
      debug 'INFO' "$IMG_FILE is ${AFTER_SIZE}MiB with $(( ADDED_SPACE / 1024 / 1024 ))MiB extra space included"
    fi
    debug 'INFO' 'Img file created'
  else
    echo -e "## ${Green}Backup done.${NC}"
    echo '##############################################################################'
    echo "## Write to logfile: $DEBUG"
    echo "## Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "## Use exclude.txt: $EXCLUDE_FILE"
    echo "## $IMG_FILE is ${AFTER_SIZE}MiB"
    debug 'INFO' "$IMG_FILE is ${AFTER_SIZE}MiB"
    debug 'INFO' 'Img file updated'
  fi
  if [ "$AUTOEXPAND" = true ]; then
    echo -e "## ${Yellow}Please wait for the system to reboot after restoring an image with autoexpansion.${NC}"
  fi
  echo '##############################################################################'
  debug 'INFO' 'Backup done'
  debug 'BREAK'
return 0
}



# Check if debugging is requested
if [ "$DEBUG" = true ]; then
  echo "## Debugging requested, writing to log file $LOG_FILE"
  debug 'INFO' "Debugging requested, writing to log file $LOG_FILE"
fi

debug 'INFO' "Script started with: $STARTLINE"

# Make sure absolute path is used on img file
if ! [[ "$IMG_FILE" =~ ^[/|.] ]]; then
  debug 'INFO' 'Direct path not provided for img file, adding pwd to variable'
  IMG_FILE="$(pwd)/$IMG_FILE"
elif [[ "$IMG_FILE" =~ ^[.] ]]; then
  debug 'INFO' 'Path to img file starting with ".", removing dot adding pwd to variable'
  IMG_FILE="$(pwd)${IMG_FILE:1}"
fi

# Set zoom type
if [ "$ZOOM" = false ]; then
  SLEEPING='sleep 1'
  echo '## Zoom speed NOT requested...'
  debug 'INFO' "Zoom speed NOT requested, setting SLEEPING=$SLEEPING | ZOOM=$ZOOM"
  $SLEEPING
else
  SLEEPING=''
  echo '## Zoom speed requested...'
  debug 'INFO' "Zoom speed requested, setting SLEEPING to empty variable | ZOOM=$ZOOM"
fi

# Check if the image file has the correct extension
if [[ "$IMG_FILE" != *.img ]]; then
  echo 'ERROR! File must have .img extension'
  debug 'ERROR' 'File must have .img extension, exit 3'
  exit 3
fi

# Setting ADDED_SPACE to 0 if AUTORESIZE_RUN option is enabled
if [ "$AUTORESIZE_RUN" = true ] && [ "$LOOPRUN" = false ]; then
  ADDED_SPACE=0
  debug 'INFO' '-a selected by user, setting ADDED_SPACE to 0 (non-zero value)'
  debug 'DEBUG' "ADDED_SPACE=$ADDED_SPACE"
fi

# Setting ADDED_SPACE to 0 if update is requested and variable ADDED_SPACE is a zero value
if [ $UPDATE = true ] && [ -z "$ADDED_SPACE" ] && [ "$LOOPRUN" = false ]; then
  ADDED_SPACE=0
  debug 'INFO' '-U selected, -a not selected or [extra space] not provided by user, setting ADDED_SPACE to 0 (non-zero value)'
  debug 'DEBUG' "ADDED_SPACE=$ADDED_SPACE"
fi

# Setting ADDED_SPACE to 0 if --loop is selected without providing [extra space]
if [ "$LOOPRUN" = true ] && [ -z "$ADDED_SPACE" ]; then
  ADDED_SPACE=0
  debug 'INFO' '--loop selected and [extra space] not provided by user, setting ADDED_SPACE to 0 (non-zero value)'
  debug 'DEBUG' "ADDED_SPACE=$ADDED_SPACE"
fi

# Regular expression for whole numbers
RE='^[0-9]+$'

# Validate the added space argument as a whole number
if ! [[ "$ADDED_SPACE" =~ $RE ]]; then
  debug 'WARNING' 'User defined ADDED_SPACE is not a regualar expression (whole number)'
  COUNTER=0
  while ! [[ "$ADDED_SPACE" =~ $RE ]]
  do
    if [ "$COUNTER" -gt 0 ]; then
      echo 'ERROR!'
      debug 'INFO' 'ERROR'
    fi
    echo 'Added space must be a whole number'
    echo 'How much space in MiB should be added?'
    debug 'INFO' 'Added space must be a whole number'
    debug 'INFO' 'How much space in MiB should be added?'
    read ADDED_SPACE
    (( COUNTER++ ))
    #(( COUNTER += 1 ))
    debug 'USER_INPUT' "User requested ${ADDED_SPACE}MiB as ADDED_SPACE"
  done
  typeset -i ADDED_SPACE
fi

# If --loop is requested, execute looprun function. Will exit script within the function
if [ "$LOOPRUN" = true ]; then
  debug 'INFO' '--loop selected by user, running function: looprun'
  looprun
fi

echo '## Scanning filesystem and calculating...'

# Check what filesystem root is using and set LOCAL_DEV_PATH & PARTITION_TABLE
FSTYPE=$(lsblk -lo mountpoint,fstype | grep '/ ' | awk '{print $2}')
debug 'INFO' "$FSTYPE root filesystem detected"
debug 'DEBUG' "FSTYPE=$FSTYPE"
if [ "$FSTYPE" == 'ext4' ] || [ "$FSTYPE" == 'f2fs' ]; then
  LOCAL_DEV_PTUUID=$(lsblk -lpo mountpoint,ptuuid | grep '/ ' | awk '{print $2}')
else
  LOCAL_DEV_PTUUID=$(lsblk -lpo fsroots,ptuuid | grep '/ ' | awk '{print $2}')
fi
LOCAL_DEV_PATH=$(lsblk -lpo ptuuid,type,path | grep "$LOCAL_DEV_PTUUID" | grep 'disk' | awk '{print $3}')
debug 'DEBUG' "LOCAL_DEV_PTUUID=$LOCAL_DEV_PTUUID | LOCAL_DEV_PATH=$LOCAL_DEV_PATH"
PARTITION_TABLE=$(parted "$LOCAL_DEV_PATH" print | grep -i 'Partition Table' | awk '{print $3}')
#PARTITION_TABLE=$(blkid "$LOCAL_DEV_PATH" | sed -n 's|^.*PTTYPE="\(\S\+\)".*|\1|p')

if [ "$FSTYPE" == 'f2fs' ] || [ "$F2FS" = true ]; then
  if [ "$FSTYPE" == 'f2fs' ] && [ "$F2FS" = true ]; then
    echo 'ERROR! --f2fs selected on f2fs root filesystem, conversion not needed'
    debug 'ERROR' '--f2fs selected on f2fs root filesystem, conversion not needed, exit 3'
    exit 3
  elif [ "$F2FS" = true ] && [ "$UPDATE" = true ]; then
    echo 'ERROR! --f2fs selected in combination with -U, conversion not possible'
    echo 'Create new img to enable f2fs conversion'
    debug 'ERROR' '--f2fs selected in combination with -U, conversion not possible, exit 3'
    exit 3
  elif [ "$FSTYPE" == 'f2fs' ] && [ "$UPDATE" = true ] && [ "$AUTORESIZE_RUN" = true ]; then
    echo 'ERROR! -U selected in combination with -a , operation not supported'
    echo 'Only creation of new img backups support operations with -a when using f2fs on root'
    debug 'ERROR' '-U selected in combination with -a, operation not supported, exit 3'
    exit 3
  elif [ "$FSTYPE" == 'f2fs' ] && [ "$UPDATE" = true ] && [ "$ADDED_SPACE" -ne 0 ]; then
    echo 'ERROR! -U selected in combination with [extra space], operation not supported'
    echo 'Only creation of new img backups support operations with [extra space] when using f2fs on root'
    debug 'ERROR' '-U selected in combination with [extra space], operation not supported, exit 3'
    exit 3
  fi
  debug 'INFO' 'f2fs filesystem or conversion to f2fs requested, disabling autoexpansion'
  AUTOEXPAND=false
fi

# Enter variables into logfile
if [ "$DEBUG" = true ]; then
  debug 'BREAK'
  debug 'DEBUG' "IMG_FILE=$IMG_FILE"
  debug 'DEBUG' "PARTITION_TABLE=$PARTITION_TABLE"
  debug 'DEBUG' "UPDATE=$UPDATE"
  debug 'DEBUG' "AUTORESIZE_RUN=$AUTORESIZE_RUN"
  debug 'DEBUG' "PROMPTS=$PROMPTS"
  debug 'DEBUG' "EXCLUDE_FILE=$EXCLUDE_FILE"
  debug 'DEBUG' "AUTOEXPAND=$AUTOEXPAND"
  debug 'DEBUG' "RSYNC_DELETE=$RSYNC_DELETE"
  debug 'DEBUG' "F2FS=$F2FS"
  debug 'DEBUG' "TTY_AVAILABILITY=$TTY_AVAILABILITY"
  debug 'BREAK'
fi

# Check if usage of exclude.txt is requested
if [ "$EXCLUDE_FILE" = true ]; then
  debug 'INFO' "-f selected by user, using $(dirname $0)/exclude.txt"
  if ! [ -f $(dirname "$0")/exclude.txt ]; then
    echo 'ERROR! exclude.txt is not present in script directory!'
    debug 'ERROR' 'exclude.txt does not exist in script directory, exit 3'
    exit 3
  fi
  debug 'DEBUG' "$(dirname $0)/exclude.txt exists"
else
  debug 'INFO' '-f NOT selected by user, using default exclude directories'
fi

if [ "$UPDATE" != true ]; then
  debug 'INFO' 'Running function: make_img'
  debug 'BREAK'
  make_img
else
  debug 'INFO' '-U selected by user, running function: do_backup'
  debug 'BREAK'
  do_backup
fi

# Check if autoexpansion is requested and run required function
if [ "$AUTOEXPAND" = true ]; then
  echo '## Enabling fs-autoexpand...'
  debug 'INFO' 'Checking OS for autoexpand function'
  $SLEEPING
  if grep -qsi 'manjaro' /etc/os-release; then
    echo '## Manjaro OS detected...'
    debug 'INFO' 'Manjaro OS detected'
    debug 'INFO' 'Running function: autoexpansion_manjaro'
    $SLEEPING
    autoexpansion_manjaro
  elif [ -e /etc/armbian-release ] || grep -qsi 'armbian' /etc/os-release; then
    echo '## Armbian OS detected...'
    debug 'INFO' 'Armbian OS detected'
    debug 'INFO' 'Running function: autoexpansion_armbian'
    $SLEEPING
    autoexpansion_armbian
  elif [ -e /etc/apt/sources.list.d/raspi.list ]; then
    echo '## Raspberry pi detected...'
    debug 'INFO' 'Raspberry pi detected'
    debug 'INFO' 'Running function: autoexpansion_rpi'
    $SLEEPING
    autoexpansion_rpi
  elif grep -qsi 'archlinuxarm' /etc/os-release; then
    echo '## ArchLinuxArm detected...'
    debug 'INFO' 'ArchLinuxArm detected'
    debug 'INFO' 'Running function: autoexpansion_arch'
    $SLEEPING
    autoexpansion_arch
  else
    echo '## No autoexpand option available for this OS...'
    debug 'WARNING' 'No autoexpand option available for this OS'
    AUTOEXPAND='failed'
    $SLEEPING
  fi
fi

print_result

exit 0
