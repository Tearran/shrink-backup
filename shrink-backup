#!/usr/bin/env bash
#
# shrink-backup
# version 0.9.3
# backup tool for backing up and updating .img files with autoexpansion on various operating systems
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    09/2023
#    Marcus Johansson
#    https://github.com/UnconnectedBedna/shrink-backup
##########################################################################

# Function to clean up resources on script exit or termination
function cleanup() {
  # exit 1 = later/normal error
  # exit 2 = early/clean error
  # exit 3 = stopped by user
  local exit_code="$?"

  if [ "$exit_code" -ne 2 ]; then

    if [ "$exit_code" -eq 0 ]; then
      debug 'DEBUG' 'Cleanup function called with exit 0'
    elif [ "$exit_code" -eq 3 ]; then
      echo '## Script stopped by user...'
      debug 'WARNING' 'Script stopped by user, exit 3'
    elif [ "$exit_code" -ne 0 ]; then
      echo '## Cleanup function called with non zero exit code, something went wrong!!!'
      debug 'ERROR' "Cleanup function called with non zero exit code: exit $exit_code"
    fi

    echo '## Exiting and cleaning up...'
    echo '## Please stand by...'

    if [ -n "$BOOT_PATH" ] && grep -qs "${TMP_DIR}${BOOT_PATH} " /proc/mounts; then
      umount "${TMP_DIR}${BOOT_PATH}"
      debug 'DEBUG' "Unmounting boot partition in cleanup function: umount ${TMP_DIR}${BOOT_PATH}"
    fi
    if [ -n "$TMP_DIR" ] && grep -qs "$TMP_DIR " /proc/mounts; then
      umount "$TMP_DIR"
      debug 'DEBUG' "Unmounting root partition in cleanup function: umount $TMP_DIR"
    fi
    if losetup /dev/loop0 &>/dev/null; then
      losetup -d /dev/loop0
      debug 'DEBUG' 'Removing loop0 in cleanup function: losetup -d /dev/loop0'
    fi
    if losetup /dev/loop1 &>/dev/null; then
      losetup -d /dev/loop1
      debug 'DEBUG' 'Removing loop1 in cleanup function: losetup -d /dev/loop1'
    fi
    if [ -d "$TMP_DIR" ]; then
      rm -rf "$TMP_DIR"
      debug 'DEBUG' "Removing temp directory in cleanup function: rm -rf $TMP_DIR"
    fi
    if [ -f "$tmp_file" ]; then
      rm "$tmp_file"
      debug 'DEBUG' "Removing temp file in cleanup function: rm $tmp_file"
    fi

    echo '## Done.'
    echo "## Elapsed time: $(date -d@$SECONDS -u +%M.%S)"
    debug 'INFO' "Elapsed time: $(date -d@$SECONDS -u +%M.%S)"
    debug 'DEBUG' 'Exiting script'
  fi
  echo '##############################################################################' >> "$LOG_FILE"
}
trap cleanup EXIT SIGTERM
trap "exit 3" SIGINT

# Function to pause script execution and prompt for user input
function pause() {
  read -p "$*"
}

# Uncomment the following line to enable the pause function
#pause 'Press [Enter] key to continue...'

# Set default values for script options
PROMPTS=true
DEBUG=false
EXCLUDE_FILE=false
AUTOEXPAND=true
RESIZE2FS_RUN=false
UPDATE=false
LOG_FILE="$(dirname "$0")/shrink-backup.log"

# Function to display help information, debug is not configured/working
help() {
  local help
  read -r -d '' help << EOM
Script for creating an .img file and subsequently keeing it updated (-U), autoexpansion is enabled by default
Directory where .img file is created is automatically excluded in backup
########################################################################
Usage: sudo $(basename "$0") [-Uatyelh] imagefile.img [extra space (MB)]
  -U         Update the img file (rsync to existing backup .img), no resizing, -a is disregarded
  -a         Let resize2fs decide minimum space (extra space is ignored), disabled if using -U
  -t         Use exclude.txt in same folder as script to set excluded directories
             One directory per line: "/dir" or "/dir/*" to only exclude contents
  -y         Disable prompts in script
  -e         DO NOT expand filesystem when image is booted
  -l         Write debug messages in logfile shrink-backup.log located in same directory as script
  -h --help  Show this help snippet
########################################################################
Example: sudo $(basename "$0") -a /path/to/backup.img
Example: sudo $(basename "$0") -e -y /path/to/backup.img 1000
Example: sudo $(basename "$0") -Utl /path/to/backup.img
EOM
  echo "$help"
  exit 2
}

# Parse command-line options
while getopts ":Uatyelh" opt; do
  case ${opt} in
    U) UPDATE=true;;
    a) RESIZE2FS_RUN=true;;
    t) EXCLUDE_FILE=true;;
    y) PROMPTS=false;;
    e) AUTOEXPAND=false;;
    l) DEBUG=true;;
    h) help;;
    *) help;;
  esac
done
#shift $((OPTIND-1))

# Check if script is run as root
if [ "$EUID" != 0 ]; then
  echo 'THIS SCRIPT MUST BE RUN AS ROOT!'
  help
fi



function debug() {
  local log_level="$1"
  local log_message="$2"
  if [ "$DEBUG" == true ]; then
    if [ "$log_level" == 'BREAK' ]; then
      echo '------------------------------------------------------------------------------' >> "$LOG_FILE"
    else
      echo -e "$(date +"%Y-%m-%d %H:%M:%S") [$log_level] - $log_message" >> "$LOG_FILE"
    fi
  fi
}



# Function to rsync to img file
function do_rsync() {
  IMG_PATH=$(dirname "$IMG_FILE")
  debug 'INFO' "Backing up to ${IMG_PATH}${IMG_FILE}"
  debug 'INFO' 'Creating temporary file to store rsync output'
  tmp_file=$(mktemp -t rsync-XXXXXXXXXX)
  debug 'DEBUG' "Running: mktemp -d -t rsync-XXXXXXXXXX, tmp_file=$tmp_file"

  if [ "$EXCLUDE_FILE" == true ]; then
    debug 'DEBUG' "Running: rsync -ahvD --exclude-from=$(dirname $0)/exclude.txt --exclude={${IMG_PATH}/*,${TMP_DIR},${tmp_file}} --info=progress2 --stats --delete --force --partial --delete-excluded / $TMP_DIR"
    rsync -ahvD --exclude-from=$(dirname "$0")/exclude.txt --exclude={${IMG_PATH}/*,${TMP_DIR},${tmp_file}} --info=progress2 --stats --delete --force --partial --delete-excluded / "$TMP_DIR" 2>&1 | tee /dev/tty  > "$tmp_file"
    # Get the exit status of rsync from PIPESTATUS
    if [ "${PIPESTATUS[0]}" -ne 0 ]; then
      output=$(tail -16 "$tmp_file")
      echo -e "$output\n## RSYNC FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "RSYNC FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  else
    debug 'DEBUG' "Running: rsync -ahvD --exclude={/lost+found,/proc/*,/sys/*,/dev/*,/tmp/*,/run/*,/mnt/*,/media/*,${IMG_PATH}/*} --info=progress2 --stats --delete --force --partial --delete-excluded / $TMP_DIR"
    rsync -ahvD --exclude={/lost+found,/proc/*,/sys/*,/dev/*,/tmp/*,/run/*,/mnt/*,/media/*,${IMG_PATH}/*} --info=progress2 --stats --delete --force --partial --delete-excluded / "$TMP_DIR" 2>&1 | tee /dev/tty > "$tmp_file"
    if [ "${PIPESTATUS[0]}" -ne 0 ]; then
      output=$(tail -16 "$tmp_file")
      echo -e "$output\n## RSYNC FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "RSYNC FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
  fi
  echo '## Rsync done...'
  output=$(tail -16 "$tmp_file")
  debug 'BREAK'
  debug 'INFO' "Rsync report:\n$output\n------------------------------------------------------------------------------"
  debug 'INFO' 'Rsync done'
  sleep 4
}



# Function to create a backup img file
function make_img() {
  # Set ADDED_SPACE to 0 if RESIZE2FS_RUN option is enabled
  if [ "$RESIZE2FS_RUN" == true ]; then
    debug 'INFO' '-a selected by user, setting ADDED_SPACE=0'
    ADDED_SPACE=0
  fi

  # Regular expression for whole numbers
  RE='^[0-9]+$'

  # Validate the added space argument as a whole number
  # -z = zero value, -n = non-zero value, -f = file, || = or, && = and
  if ! [[ "$ADDED_SPACE" =~ $RE ]]; then
    debug 'WARNING' 'User defined ADDED_SPACE is not a regualar expression'
    while ! [[ "$ADDED_SPACE" =~ $RE ]]
    do
      #if [ "$COUNTER" > 0 ] || test -n "$ADDED_SPACE"; then
      if [ "$COUNTER" -gt 0 ] || [ -n "$ADDED_SPACE" ]; then
        echo 'Added space must be a whole number'
        debug 'INFO' 'Added space must be a whole number'
      fi
      echo 'How much space in MB should be added?'
      debug 'INFO' 'How much space in MB should be added?'
      read ADDED_SPACE
      (( COUNTER++ ))
      #(( COUNTER += 1 ))
    done
    debug 'USER_INPUT' "User requested ${ADDED_SPACE}MB as ADDED_SPACE"
  fi

  # Check if separate boot and root partition exists and set ROOT_DEV_PATH and BOOT_DEV_PATH accordingly
  MAJ_DEV_NUM=$(lsblk -lpo mountpoint,maj:min,type,path | grep '/ ' | awk '{print $2}' | cut -d : -f 1)
  HD_DEV_PATH=$(lsblk -lpo maj:min,type,path | grep "$MAJ_DEV_NUM" | grep 'disk' | awk '{print $3}')
  debug 'DEBUG' "Checking what disk-device root resides on. Setting HD_DEV_PATH=$HD_DEV_PATH"
    if [ $(lsblk | grep -c 'boot') -ne 0 ]; then
      BOOT_DEV_PATH=$(lsblk -lpo mountpoint,path | grep 'boot' | awk '{print $2}')
      ROOT_DEV_PATH=$(lsblk -lpo mountpoint,path | grep '/ ' | awk '{print $2}')
      debug 'DEBUG' "2 partitions detected, setting ROOT_DEV_PATH=$ROOT_DEV_PATH and BOOT_DEV_PATH=$BOOT_DEV_PATH"
    else
      ROOT_DEV_PATH=$(lsblk -lpo mountpoint,path | grep '/ ' | awk '{print $2}')
      debug 'DEBUG' "1 partition detected, setting ROOT_DEV_PATH=$ROOT_DEV_PATH"
    fi

  # Collecting data for calculations
  debug 'DEBUG' 'Calculating size for dd to cover bootsector in blocks (512B block size) and adding 256 blocks to overlap into root'
  ROOT_DEV_START=$(fdisk -lo start "$HD_DEV_PATH" | tail -1) # blocks, 512B block size
  BOOTSECTOR=$(( ROOT_DEV_START - 1 )) # blocks, to set the actual bootsector
  DDBOOTSECTOR=$(( BOOTSECTOR + 256 )) # blocks, adding 256 extra to cover root filesystem
  ROOT_DEV_START=$(( ROOT_DEV_START * 512 )) # bytes
  debug 'INFO' "BOOTSECTOR=${BOOTSECTOR} blocks"
  debug 'INFO' "DDBOOTSECTOR=${DDBOOTSECTOR} blocks"
  BOOTSECTOR=$(( BOOTSECTOR * 512 )) # bytes
  debug 'INFO' "BOOTSECTOR=${BOOTSECTOR} Bytes"
  BLOCKSIZE=$(dumpe2fs -h "$ROOT_DEV_PATH" | grep "Block size" | awk '{print $3}') # bytes
  RESIZE2FS_MIN=$(resize2fs -P "$ROOT_DEV_PATH" | awk '{print $7}' | tail -1) # blocks
  RESIZE2FS_MIN=$(( RESIZE2FS_MIN * BLOCKSIZE )) # bytes
  DF_OUTPUT=( $(df / --output=size,avail | tail -1) ) # 1k blocks, 0 is the first position in an array
  USED_SPACE=$(( (${DF_OUTPUT[0]} - ${DF_OUTPUT[1]}) * 1024 )) # bytes, df is in 1k blocks, 0 is the first position
  #DF_OUTPUT=( $(df / --output=used | tail -1) ) # 1k blocks
  #USED_SPACE=$(( DF_OUTPUT * 1024 )) # bytes, df is in 1k blocks
  ADDED_SPACE=$(( ADDED_SPACE * 1024 * 1024 )) # bytes

  # Use resize2fs to calulate size if option is selected
  if [ "$RESIZE2FS_RUN" == true ]; then
    debug 'DEBUG' 'Setting TOTAL (space needed for files on root) to size calculated by resize2fs'
    debug 'INFO' "RESIZE2FS_MIN=${RESIZE2FS_MIN} Bytes"
    TOTAL=$RESIZE2FS_MIN # bytes
  else
    debug 'DEBUG' 'Calculating TOTAL (space needed for files on root) by adding USED_SPACE and ADDED_SPACE'
    debug 'INFO' "USED_SPACE=${USED_SPACE} Bytes"
    debug 'INFO' "ADDED_SPACE=${ADDED_SPACE} Bytes"
    TOTAL=$(( USED_SPACE + ADDED_SPACE )) # bytes
  fi
  debug 'INFO' "TOTAL=${TOTAL} Bytes"

  TRUNCATE_TOTAL=$(( BOOTSECTOR + TOTAL )) # bytes
  debug 'DEBUG' 'Calculating .img file size by adding BOOTSECTOR to TOTAL'
  debug 'INFO' "TRUNCATE_TOTAL=${TRUNCATE_TOTAL} Bytes"
  #TRUNCATE_TOTAL=$(( BLOCKSIZE + BOOTSECTOR + TOTAL )) # bytes, this was when I was using end instead of start with fdisk
  #TRUNCATE_TOTAL=$(( ( 1 + 33 ) * BLOCKSIZE + TOTAL + BOOTSECTOR )) # bytes, something about GPT needing 33 extra blocks

  # Add 128MB extra space if resize2fs reports bigger minimum than created
  if [ "$TOTAL" -lt "$RESIZE2FS_MIN" ]; then
    debug 'DEBUG' 'Adding WIGGLEROOM (128MB) because manually requested ADDED_SPACE is less than resize2fs caluclated size'
    WIGGLEROOM=134217728 # 128MB = 134217728B, 192MB = 201326592B
    TRUNCATE_TOTAL=$(( TRUNCATE_TOTAL + WIGGLEROOM ))
    debug 'INFO' "RESIZE2FS_MIN=${RESIZE2FS_MIN} Bytes"
    debug 'INFO' "WIGGLEROOM=${WIGGLEROOM} Bytes"
    debug 'INFO' "TRUNCATE_TOTAL=${TRUNCATE_TOTAL} Bytes"
  fi

  # Check if user input is required and print changes that will be performed
  if [ "$PROMPTS" == true ]; then
    if [ "$RESIZE2FS_RUN" == true ]; then
      echo ''
      echo '##############################################################################'
      echo "# A backup will be created at $IMG_FILE"
      echo "# Write to logfile: $DEBUG"
      echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
      echo "# Use exclude.txt: $EXCLUDE_FILE"
      echo "# Bootsector size: $(( BOOTSECTOR / 1024 / 1024 ))MB"
      echo "# Resize2fs decide minimum (root partition): $(( RESIZE2FS_MIN / 1024 / 1024 ))MB"
      echo "# Total img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MB"
      echo '##############################################################################'
    else
      echo ''
      echo '##############################################################################'
      echo "# A backup will be created at $IMG_FILE"
      echo "# Write to logfile: $DEBUG"
      echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
      echo "# Use exclude.txt: $EXCLUDE_FILE"
      echo "# Bootsector size: $(( BOOTSECTOR / 1024 / 1024 ))MB"
      echo "# Total img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MB with $(( ADDED_SPACE / 1024 / 1024 ))MB extra space included."
      echo '##############################################################################'
    fi

    # Confirm with user input
    read -p "Do you want to continue? [y/n] " -n 1 -r
    debug 'INFO' 'Do you want to continue? [y/n]'
    if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
      debug 'USER_INPUT' 'Aborted by user, exit 2'
      echo ''
      echo 'Aborting...'
      exit 2
    fi
    echo ''
    debug 'USER_INPUT' 'Y or y pressed to confirm'

    if test -f "$IMG_FILE"; then
      debug 'WARNING' "$IMG_FILE ALREADY EXISTS!"
      echo 'WARNING!!! WARNING!!! WARNING!!!'
      echo "$IMG_FILE"
      echo 'FILE ALREADY EXISTS!!!'
      read -p "Do you want to overwrite? [y/n] " -n 1 -r
      debug 'INFO' 'Do you want to overwrite? [y/n]'
      if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
        debug 'USER_INPUT' 'Aborted by user, exit 2'
        echo ''
        echo 'Aborting...'
        exit 2
      fi
      echo ''
      debug 'USER_INPUT' 'Overwrite confirmed by user'
    fi
  else
    debug 'WARNING' '-y selected by user. prompts are disabled'
    if [ "$RESIZE2FS_RUN" == true ]; then
      echo '##############################################################################'
      echo '# DISABLE PROMPTS SELECTED (-y), NO WARNINGS ABOUT DELETION!!!'
      echo "# A backup will be created at $IMG_FILE"
      echo "# Write to logfile: $DEBUG"
      echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
      echo "# Use exclude.txt: $EXCLUDE_FILE"
      echo "# Bootsector size: $(( BOOTSECTOR / 1024 / 1024 ))MB"
      echo "# Resize2fs decide minimum (root partition): $(( RESIZE2FS_MIN / 1024 / 1024 ))MB"
      echo "# Total img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MB"
      echo '# PRESS CTRL+C WITHIN 5s TO CANCEL!'
      echo '##############################################################################'
    else
      echo '##############################################################################'
      echo '# DISABLE PROMPTS SELECTED (-y), NO WARNINGS ABOUT DELETION!!!'
      echo "# A backup will be created at $IMG_FILE"
      echo "# Write to logfile: $DEBUG"
      echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
      echo "# Use exclude.txt: $EXCLUDE_FILE"
      echo "# Bootsector size: $(( BOOTSECTOR / 1024 / 1024 ))MB"
      echo "# Total img size: $(( TRUNCATE_TOTAL / 1024 / 1024 ))MB with $(( ADDED_SPACE / 1024 / 1024 ))MB extra space included."
      echo '# PRESS CTRL+C WITHIN 5s TO CANCEL!'
      echo '##############################################################################'
    fi
    sleep 6
  fi

  # Delete existing file if user validation above passed
  if [ -f "$IMG_FILE" ]; then
    debug 'DEBUG' "Removing $IMG_FILE"
    echo '## Removing old img file...'
    rm "$IMG_FILE"
    sleep 1
  fi

  # Create and dd bootsector
  echo '## Creating bootsector...'
  debug 'INFO' "Using dd to create bootsector, bs=512 count=$DDBOOTSECTOR"
  if ! output=$(dd bs=512 count=$DDBOOTSECTOR if="$HD_DEV_PATH" of="$IMG_FILE" conv=noerror,sync status=progress 2>&1 | tee /dev/tty); then
    echo -e "$output\n## DD TO BOOTSECTOR FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "DD TO BOOTSECTOR FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  output=$(echo "$output" | tail -3 )
  debug 'BREAK'
  debug 'DEBUG' "Running: dd bs=512 count=$DDBOOTSECTOR if=$HD_DEV_PATH of=$IMG_FILE conv=noerror,sync status=progress\n$output\n------------------------------------------------------------------------------"
  sleep 2

  # Truncate file to correct size
  echo "## Resizing img file to $(( TRUNCATE_TOTAL / 1024 / 1024 ))MB..."
  debug 'INFO' "Using truncate to resize img file to $(( TRUNCATE_TOTAL / 1024 / 1024 ))MB"
  if ! output=$(truncate --size=$TRUNCATE_TOTAL "$IMG_FILE" 2>&1); then
    echo -e "$output\n## TRUNCATE FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "TRUNCATE FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  debug 'DEBUG' "Running: truncate --size=$TRUNCATE_TOTAL $IMG_FILE"
  sleep 1

  # Create loopback with img file
  echo '## Looping img file...'
  debug 'INFO' "Using losetup -P to loop $IMG_FILE"
  if ! output=$(losetup -P /dev/loop0 "$IMG_FILE" 2>&1); then
    echo -e "$output\n## LOSETUP FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "LOSETUP FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  debug 'DEBUG' "Running: losetup -P /dev/loop0 $IMG_FILE"
  sleep 1

  # Remove partition
  echo '## Removing root partition...'
  debug 'INFO' 'Using sfdisk to remove root partition'
  if [ -e "$BOOT_DEV_PATH" ]; then
    LOOP0='/dev/loop0p2'
    LOOP1='/dev/loop0p1'
    debug 'DEBUG' "2 partitions detected, setting LOOP0=$LOOP0 and LOOP1=$LOOP1"
    if ! output=$(sfdisk --delete -f -q /dev/loop0 2 2>&1); then
      echo -e "$output\n## SFDISK FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "SFDISK FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'DEBUG' "Running: sfdisk --delete -f -q /dev/loop0 2"
  else
    LOOP0='/dev/loop0p1'
    debug 'DEBUG' "1 partition detected, setting LOOP0=$LOOP0"
    if ! output=$(sfdisk --delete -f -q /dev/loop0 1 2>&1); then
      echo -e "$output\n## SFDISK FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "SFDISK FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'DEBUG' "Running: sfdisk --delete -f -q /dev/loop0 1"
  fi
  sleep 2

  # Recreate partition, BOOTSECTOR is actually the startsector of root
  echo '## Recreating root partition...'
  debug 'INFO' 'Using parted to recreate root partition'
  if ! output=$(parted -s -a none /dev/loop0 unit B mkpart primary ext4 "$ROOT_DEV_START" 100% 2>&1); then
    echo -e "$output\n## PARTED FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "PARTED FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  debug 'DEBUG' "Running: parted -s -a none /dev/loop0 unit B mkpart primary ext4 $ROOT_DEV_START 100%"
  sleep 2

  # Format filesystem
  echo '## Formatting filesystem...'
  debug 'INFO' 'Using mkfs.ext4 to format root filesystem'
  LABEL=( $(lsblk -o label "$ROOT_DEV_PATH" | tail -1) )
  UUID=( $(lsblk -o uuid "$ROOT_DEV_PATH" | tail -1) )
  if ! output=$(mkfs.ext4 "$LOOP0" -U "$UUID" -L "$LABEL" -F -v 2>&1 | tee /dev/tty ); then
    echo -e "$output\n## MKFS.EXT4 FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "MKFS.EXT4 FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  debug 'BREAK'
  debug 'DEBUG' "Running: mkfs.ext4 $LOOP0 -U $UUID -L $LABEL -F -v\n$output\n------------------------------------------------------------------------------"
  sleep 2

  # Make sure everything worked
  echo '## Scanning filesystem...'
  debug 'INFO' 'Using e2fsck to check filesystem'
  if ! output=$(e2fsck -y -f "$LOOP0" 2>&1); then
    echo -e "$output\n## E2FSCK FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "E2FSCK FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  echo "$output"
  debug 'BREAK'
  debug 'DEBUG' "Running: e2fsck -y -f $LOOP0\n$output\n------------------------------------------------------------------------------"
  sleep 1

  # Create a temporary directory to mount the image
  echo '## Mounting img file to temp directory...'
  debug 'INFO' 'Creating temp directory and mounting img file'
  TMP_DIR=$(mktemp -d -t shrink_img-XXXXXXXXXX)
  debug 'DEBUG' "Running: mktemp -d -t shrink_img-XXXXXXXXXX, TMP_DIR=$TMP_DIR"
  if ! output=$(mount "$LOOP0" "$TMP_DIR" 2>&1); then
    echo -e "$output\n## ROOT MOUNT FAILED!!!"
    debug 'BREAK'
    debug 'ERROR' "ROOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  debug 'DEBUG' "Running: mount $LOOP0 $TMP_DIR"
  sleep 1
  if [ -e "$BOOT_DEV_PATH" ]; then
    echo '## Mounting boot partition...'
    debug 'INFO' 'Separate boot partition detected, mounting boot inside img file'
    BOOT_PATH=$(cat /etc/fstab | grep '/boot' | awk '{print $2}')
    debug 'DEBUG' "Fetching boot mount path from fstab, BOOT_PATH=$BOOT_PATH"
    if ! [ -d ${TMP_DIR}${BOOT_PATH} ]; then
      mkdir -p ${TMP_DIR}${BOOT_PATH}
      debug 'DEBUG' "Creating boot directory in img file, mkdir ${TMP_DIR}/boot"
    fi
    if ! output=$(mount "$LOOP1" "${TMP_DIR}${BOOT_PATH}" 2>&1); then
      echo -e "$output\n## BOOT MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "BOOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'DEBUG' "Running: mount $LOOP1 ${TMP_DIR}${BOOT_PATH}"
    sleep 1
  fi

  # Copy the files
  echo '## Backing up files...'
  debug 'DEBUG' 'Executing do_rsync function'
  sleep 1
  do_rsync

  # Final check of created file
  echo '## Finalizing filesystem...'
  echo '## Please stand by...'
  debug 'INFO' 'Finalizing filesystem'
  sleep 1

  if [ -n "$BOOT_PATH" ]; then
    debug 'DEBUG' "Unmounting boot partition: umount ${TMP_DIR}${BOOT_PATH}"
    umount "${TMP_DIR}${BOOT_PATH}"
    sleep 1
  fi

  debug 'DEBUG' "Unmounting root partition: umount $TMP_DIR"
  umount "$TMP_DIR"
  sleep 1

  output=$(e2fsck -y -f -v "$LOOP0" 2>&1)
  echo "$output"
  debug 'BREAK'
  debug 'DEBUG' "Running: e2fsck -y -f -v $LOOP0\n$output\n------------------------------------------------------------------------------"

  # Remounting if autoexpansion is requested
  if [ "$AUTOEXPAND" == true ]; then
    debug 'DEBUG' 'Remounting for autoexpansion function'
    if ! output=$(mount "$LOOP0" "$TMP_DIR" 2>&1); then
      echo -e "$output\n## ROOT MOUNT FAILED!!!"
      debug 'BREAK'
      debug 'ERROR' "ROOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'DEBUG' "Running: mount $LOOP0 $TMP_DIR"
    sleep 1
    if [ -e "$BOOT_DEV_PATH" ]; then
    debug 'DEBUG' 'Remounting boot inside img file'
      if ! output=$(mount "$LOOP1" "${TMP_DIR}${BOOT_PATH}" 2>&1); then
        echo -e "$output\n## BOOT MOUNT FAILED!!!"
        debug 'BREAK'
        debug 'ERROR' "BOOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
        exit 1
      fi
    fi
    debug 'DEBUG' "Running: mount $LOOP1 ${TMP_DIR}${BOOT_PATH}"
    sleep 1
  fi
}



# Function to update existing img file
function do_backup() {
  # Making sure img file exists
  if ! [ -f "$IMG_FILE" ]; then
    echo "## ERROR. $IMG_FILE does not exist!"
    debug 'ERROR' "$IMG_FILE does not exist, exit 1"
    exit 1
  fi

  # Confirm with user input if not disabled
  if [ "$PROMPTS" == true ]; then
    img_size=$(ls -lh "$IMG_FILE" | awk '{print $5}')
    echo '##############################################################################'
    echo '# IF YOU ARE UPDATING A RPI IMG MADE WITH AN OLDER VERSION OF THIS SCRIPT'
    echo '# AND HAS RESTORED THAT IMG, PLEASE MAKE A FRESH IMAGE!!!!'
    echo '# Visit https://github.com/UnconnectedBedna/shrink-backup for more info'
    echo '# ----------------------------------------------------------------------------'
    echo "# Updating $IMG_FILE"
    echo "# Write to logfile: $DEBUG"
    echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "# Use exclude.txt: $EXCLUDE_FILE"
    echo "# Total img size: $img_size"
    echo '##############################################################################'
    read -p "Do you want to continue? [y/n] " -n 1 -r
    debug 'INFO' "Updating $IMG_FILE, file size=$img_size"
    debug 'INFO' 'Do you want to continue? [y/n]'
    if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
      debug 'USER_INPUT' 'Aborted by user, exit 2'
      echo ''
      echo 'Aborting...'
      exit 2
    fi
    echo ''
    debug 'USER_INPUT' 'Y or y pressed to confirm'
  else
    echo '##############################################################################'
    echo '# IF YOU ARE UPDATING A RPI IMG MADE WITH AN OLDER VERSION OF THIS SCRIPT'
    echo '# AND HAS RESTORED THAT IMG, PLEASE MAKE A FRESH IMAGE!!!!'
    echo '# Visit https://github.com/UnconnectedBedna/shrink-backup for more info'
    echo '# ----------------------------------------------------------------------------'
    echo '# DISABLE PROMPTS SELECTED'
    echo "# Write to logfile: $DEBUG"
    echo "# Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "# Use exclude.txt: $EXCLUDE_FILE"
    echo "# Total img size: $img_size"
    echo '# PRESS CTRL+C WITHIN 5s TO CANCEL!'
    echo '##############################################################################'
    debug 'INFO' "Updating $IMG_FILE, file size=$img_size"
    sleep 6
  fi

  # Reading offset for root partition
  OFFSET=$(fdisk -lo start "$IMG_FILE" | tail -1) # blocks, 512B block size
  OFFSET=$(( OFFSET * 512 )) # bytes
  debug 'DEBUG' "Using fdisk to find root partition offset: fdisk -lo start $IMG_FILE | tail -1"
  debug 'INFO' "OFFSET=${OFFSET} Bytes"

  # Create a temporary directory to mount the image
  echo '## Mounting img file to temp directory...'
  debug 'INFO' 'Creating temp directory and mounting img file'
  TMP_DIR=$(mktemp -d -t backup-XXXXXXXXXX)
  debug 'DEBUG' "Running: mktemp -d -t backup-XXXXXXXXXX, TMP_DIR=$TMP_DIR"
  if ! output=$(mount -o loop,offset="$OFFSET",x-mount.mkdir "$IMG_FILE" "$TMP_DIR" 2>&1); then
    echo -e "$output\n## ROOT MOUNT FAILED!!!"
    debug 'ERROR' "ROOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
    exit 1
  fi
  debug 'DEBUG' "Running: mount -o loop,offset=$OFFSET,x-mount.mkdir $IMG_FILE $TMP_DIR"
  sleep 1

  # Check if multiple partitions exist
  if [ $(sudo fdisk -lo device "$IMG_FILE" | grep -c "$IMG_FILE") -gt 2 ]; then
    BOOT_DEV_PATH=$(sudo fdisk -lo device "$IMG_FILE" | grep "$IMG_FILE" | tail -2 | head -1)
    echo '## 2 partitions detected...'
    debug 'DEBUG' '2 partitions detected'
  else
    echo '## Single partition detected...'
    debug 'DEBUG' '1 partition detected'
  fi

  if [ -n "$BOOT_DEV_PATH" ]; then
    echo '## Mounting boot...'
    debug 'INFO' 'Separate boot partition detected, mounting boot inside img file'
    OFFSET_BOOT=$(fdisk -lo start "$IMG_FILE" | tail -2 | head -1) # blocks, 512B block size
    OFFSET_BOOT=$(( OFFSET_BOOT * 512 )) # bytes
    debug 'DEBUG' "Using fdisk to find boot partition offset on img file: fdisk -lo start "$IMG_FILE" | tail -2 | head -1"
    debug 'INFO' "OFFSET_BOOT=${OFFSET_BOOT} Bytes"
    BOOT_PATH=$(cat ${TMP_DIR}/etc/fstab | grep '/boot' | awk '{print $2}')
    debug 'DEBUG' "Fetching boot mount path from fstab on img file, BOOT_PATH=$BOOT_PATH"
    losetup -o "$OFFSET_BOOT" /dev/loop1 "$IMG_FILE"
    debug 'DEBUG' "Running: losetup -o $OFFSET_BOOT /dev/loop1 $IMG_FILE"
    if ! output=$(mount /dev/loop1 "${TMP_DIR}${BOOT_PATH}" 2>&1); then
      echo -e "$output\n## BOOT MOUNT FAILED!!!"
      debug 'ERROR' "BOOT MOUNT FAILED:\n$output\n------------------------------------------------------------------------------"
      exit 1
    fi
    debug 'DEBUG' "Running: mount /dev/loop1 ${TMP_DIR}${BOOT_PATH}"
    sleep 1
  fi

  # Copy the files
  echo '## Backing up files...'
  debug 'DEBUG' 'Executing do_rsync function'
  sleep 1
  do_rsync
}



# Enabling autoexpansion for Manjaro
function autoexpansion_manjaro() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.arget.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi
  # Creating autoexpansion systemd unit file expand-fs.service
  if ! [ -e "${TMP_DIR}/etc/systemd/system/expand-fs.service" ]; then
    debug 'DEBUG' 'Systemd unit expand-fs.service does not exist, creating it'
    cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
ExecStart=/bin/bash -c "/usr/bin/resize-fs || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service || exit 0"
Type=oneshot

[Install]
WantedBy=basic.target
EOF
  fi
  if ! [ -e "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Systemd service not enabled, creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi
  echo '## Manjaro filesystem autoresizing at boot...'
  debug 'INFO' 'Manjaro filesystem autoresizing at boot'
  sleep 1
}



# Enabling autoexpansion for Armbian
function autoexpansion_armbian() {
  if ! test -f "${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service"; then
    debug 'DEBUG' "Enabling systemd service by creating symlink: ln -s /lib/systemd/system/armbian-resize-filesystem.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service"
    ln -s /lib/systemd/system/armbian-resize-filesystem.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/armbian-resize-filesystem.service
  fi
  echo '## Armbian filesystem autoresizing at boot...'
  debug 'INFO' 'Armbian filesystem autoresizing at boot'
  sleep 1
}



# Enabling autoexpansion for Raspberry pi
function autoexpansion_rpi() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.arget.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi
  # Creating autoexpansion systemd unit file expand-fs.service
  if ! [ -e "${TMP_DIR}/etc/systemd/system/expand-fs.service" ]; then
    debug 'DEBUG' 'Systemd unit expand-fs.service does not exist, creating it'
    cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c "/expand-fs.sh || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service && /usr/bin/rm /expand-fs.sh && /usr/bin/rm /etc/systemd/system/expand-fs.service && /usr/sbin/reboot -f || exit 0"

[Install]
WantedBy=basic.target
EOF
  fi
  if ! [ -e "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Systemd service not enabled, creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi
  # Creating script for autoexpansion
  if ! [ -e "${TMP_DIR}/expand-fs.sh" ]; then
    debug 'DEBUG' "Creating expansion script ${TMP_DIR}/expand-fs.sh"
    cat << EOF2 > "${TMP_DIR}/expand-fs.sh"
#!/usr/bin/bash
MAJ_DEV_NUM=\$(lsblk -lpo mountpoint,maj:min,type,path | grep '/ ' | awk '{print \$2}' | cut -d : -f 1)
MIN_DEV_NUM=\$(lsblk -lpo mountpoint,maj:min,type,path | grep '/ ' | awk '{print \$2}' | cut -d : -f 2)
HD_DEV_PATH=\$(lsblk -lpo maj:min,type,path | grep "\$MAJ_DEV_NUM" | grep 'disk' | awk '{print \$3}')
ROOT_DEV_PATH=\$(lsblk -lpo mountpoint,path | grep '/ ' | awk '{print \$2}')
ROOT_DEV_START=\$(fdisk -lo start "\$HD_DEV_PATH" | tail -1)
ROOT_DEV_START=\$(( ROOT_DEV_START * 512 ))
sfdisk --delete "\$HD_DEV_PATH" "\$MIN_DEV_NUM"
sleep 1
parted -s -a none "\$HD_DEV_PATH" unit B mkpart primary "\$ROOT_DEV_START" 100%
sleep 1
resize2fs -f "\$ROOT_DEV_PATH"
sleep 1
sync
exit 0
EOF2
  fi
  if ! [ -x "${TMP_DIR}/expand-fs.sh" ]; then
    debug 'DEBUG' 'Making /expand-fs.sh executable'
    chmod +x ${TMP_DIR}/expand-fs.sh
  fi
  echo '## Raspberry pi filesystem autoresizing at boot...'
  debug 'INFO' 'Raspberry pi filesystem autoresizing at boot'
  sleep 1
}



# Enabling autoexpansion for ArchLinuxArm
function autoexpansion_arch() {
  if ! [ -d "${TMP_DIR}/etc/systemd/system/basic.target.wants" ]; then
    debug 'DEBUG' "Systemd basic.arget.wants directory does not exist, running: mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants"
    mkdir ${TMP_DIR}/etc/systemd/system/basic.target.wants
  fi
  # Creating autoexpansion systemd unit file expand-fs.service
  if ! [ -e "${TMP_DIR}/etc/systemd/system/expand-fs.service" ]; then
    debug 'DEBUG' 'Systemd unit expand-fs.service does not exist, creating it'
    cat << EOF > "${TMP_DIR}/etc/systemd/system/expand-fs.service"
[Unit]
Description=Extend root partition and resize ext4 file system
After=local-fs.target
Wants=local-fs.target

[Service]
ExecStart=/bin/bash -c "/expand-fs.sh || exit 0"
ExecStop=/bin/bash -c "/usr/bin/rm /etc/systemd/system/basic.target.wants/expand-fs.service && /usr/bin/rm /expand-fs.sh || exit 0"
Type=oneshot

[Install]
WantedBy=basic.target
EOF
  fi
  if ! [ -e "${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service" ]; then
    debug 'DEBUG' "Systemd service not enabled, creating symlink: ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service"
    ln -s /etc/systemd/system/expand-fs.service ${TMP_DIR}/etc/systemd/system/basic.target.wants/expand-fs.service
  fi
  # Creating script for autoexpansion
  if ! [ -e "${TMP_DIR}/expand-fs.sh" ]; then
    debug 'DEBUG' '/expand-fs.sh does not exist, creating'
    cat << EOF > "${TMP_DIR}/expand-fs.sh"
#!/usr/bin/bash
MAJ_DEV_NUM=\$(lsblk -lpo mountpoint,maj:min,type,path | grep '/ ' | awk '{print \$2}' | cut -d : -f 1)
HD_DEV_PATH=\$(lsblk -lpo maj:min,type,path | grep "\$MAJ_DEV_NUM" | grep 'disk' | awk '{print \$3}')
ROOT_DEV_PATH=\$(lsblk -lpo mountpoint,path | grep '/ ' | awk '{print \$2}')
ROOT_DEV_START=\$(fdisk -lo start "\$HD_DEV_PATH" | tail -1)
ROOT_DEV_START=\$(( ROOT_DEV_START * 512 ))

sfdisk --delete "\$HD_DEV_PATH" 2
parted -s -a none "\$HD_DEV_PATH" unit B mkpart primary "\$ROOT_DEV_START" 100%
resize2fs -pf "\$ROOT_DEV_PATH"

exit 0
EOF
  fi
  if ! [ -x "${TMP_DIR}/expand-fs.sh" ]; then
    debug 'DEBUG' 'Making /expand-fs.sh executable'
    chmod +x ${TMP_DIR}/expand-fs.sh
  fi
  echo '## ArchLinuxArm filesystem autoresizing at boot...'
  debug 'INFO' 'ArchLinuxArm filesystem autoresizing at boot'
  sleep 1
}



# Function to print result
function print_result() {
  if [ "$UPDATE" != true ]; then
    AFTER_SIZE=$(ls -lh "$IMG_FILE" | cut -d ' ' -f 5)
    echo '##############################################################################'
    echo '## Backup done.'
    echo "## Write to logfile: $DEBUG"
    echo "## Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "## Use exclude.txt: $EXCLUDE_FILE"
    if [ "$RESIZE2FS_RUN" = true ]; then
      echo "## $IMG_FILE is $AFTER_SIZE with a root partition of $(( RESIZE2FS_MIN / 1024 / 1024 ))MB."
      debug 'INFO' "$IMG_FILE is $AFTER_SIZE with a root partition of $(( RESIZE2FS_MIN / 1024 / 1024 ))MB"
    else
      echo "## $IMG_FILE is $AFTER_SIZE with $(( ADDED_SPACE / 1024 / 1024 ))MB extra space included."
      debug 'INFO' "$IMG_FILE is $AFTER_SIZE with $(( ADDED_SPACE / 1024 / 1024 ))MB extra space included"
    fi
    debug 'INFO' 'Img file created and backup done'
  else
    echo '##############################################################################'
    echo '## Backup done.'
    echo "## Write to logfile: $DEBUG"
    echo "## Autoexpand filesystem at boot: $AUTOEXPAND"
    echo "## Use exclude.txt: $EXCLUDE_FILE"
    debug 'INFO' 'Img file updated'
  fi
}



# Process the non-option arguments, checks/fixes if the imagefile comes before the options
while [ "$#" -gt 0 ];
do
  if [[ "$1" =~ ^- ]]; then
    shift
  else
    IMG_FILE="$1"
    ADDED_SPACE="$2"
    break
  fi

done

# Check if the image file has the correct extension
if [[ "$IMG_FILE" != *.img ]]; then
  echo 'ERROR! File must have .img extension'
  debug 'ERROR' 'File must have .img extension, exit 2'
  exit 2
fi

# Check if debugging is requested
if [ "$DEBUG" == true ]; then
  echo "## Debugging selected, writing to $LOG_FILE"
  echo '## Scanning filesystem and calculating...'
  debug 'INFO' "Debugging requested, writing to log file $(basename "$LOG_FILE")..."
  debug 'INFO' "Update existing img file selected, UPDATE=$UPDATE"
  debug 'INFO' "Requesting size from resize2fs selected, RESIZE2FS_RUN=$RESIZE2FS_RUN"
  debug 'INFO' "Prompt for user confirmation, PROMPTS=$PROMPTS"
  debug 'INFO' "Auto expansion enabled, AUTOEXPAND=$AUTOEXPAND"
fi

# Check if usage of exclude.txt us requested
if [ "$EXCLUDE_FILE" == true ]; then
  debug 'INFO' '-f selected by user, using exclude.txt'
  debug 'DEBUG' 'Checking if EXCLUDE_FILE exists'
  if ! [ -f $(dirname "$0")/exclude.txt ]; then
    echo 'ERROR! exclude.txt is not present in script directory!'
    debug 'ERROR' 'exclude.txt does not exist in script directory, exit 2'
    exit 2
  fi
  debug 'INFO' "$(dirname $0)/exclude.txt exists"
fi

if [ "$UPDATE" != true ]; then
  debug 'DEBUG' 'Executing make_img function'
  make_img
else
  debug 'DEBUG' 'User selected -U, executing do_backup function'
  do_backup
fi

# Check if autoexpansion is requested and run required function
if [ "$AUTOEXPAND" == true ]; then
  echo '## Enabling fs-autoexpand...'
  debug 'DEBUG' 'Executing expand_fs function'
  sleep 1
  if cat /etc/os-release | grep -i 'manjaro' >/dev/null; then
    echo '## Manjaro os detected...'
    debug 'INFO' 'Manjaro os detected'
    sleep 1
    autoexpansion_manjaro
  elif [ -e /etc/armbian-release ]; then
    debug 'INFO' 'Armbian os detected'
    echo '## Armbian os detected...'
    sleep 1
    autoexpansion_armbian
  elif uname -a | grep -q 'raspberry' || [ -e /etc/apt/sources.list.d/raspi.list ]; then
    debug 'INFO' 'Raspberry pi detected'
    echo '## Raspberry pi detected...'
    sleep 1
    autoexpansion_rpi
  elif grep -q 'archlinuxarm' /etc/os-release; then
    echo '## ArchLinuxArm os detected...'
    debug 'INFO' 'ArchLinuxArm os detected'
    sleep 1
    autoexpansion_arch
  else
    echo '## No autoexpand option available for this os...'
    debug 'WARNING' 'No autoexpand option available for this os'
    AUTOEXPAND='failed'
    sleep 1
  fi
fi

print_result

exit 0
